import { bNode } from "detect-browser-node-ssr";
import { browserInfo, detectEnvironmentForDbrjsLikeProject } from "@scannerproxy/browser-info";
import { curScriptDir, getAbsoluteDir } from "@scannerproxy/curscript-path";
import { licenseGetFromScriptTag, setLicense, sessionPasswordFromScriptTag, setSessionPassword, setLicenseServer, setDeviceFriendlyName, preProcessLicense, showDialog } from "@scannerproxy/dlsjs/dist/pre-process"
import MutablePromise from "mutable-promise";
import { DLRResult } from "../interface/dlrresult";
import { DLRLineResult } from "../interface/dlrlineresult";
import { DLRRuntimeSettings } from "../interface/dlrruntimesettings";
import { EnumDLRImagePixelFormat } from "../enum/enumdlrimagepixelformat";
import { EnumDLRErrorCode } from "../enum/enumdlrerrorcode";
import { LabelRecognizerException } from "../interface/labelrecognizerexception";
import { DLRReferenceRegion } from "../interface/dlrreferenceregion";
import { ScanSettings } from '../interface/scanSettings';
import { PlayCallbackInfo } from '../interface/playcallbackinfo';
import { ImageSource } from '../interface/imagesource';
import { DSImage } from '../interface/dsimage';
import { EnumDLRLocalizationSourceType } from '../enum/enumdlrlocalizationsourcetype';
import { CameraEnhancer, DCEFrame } from 'dynamsoft-camera-enhancer';
import { isImageSource, isDSImage, isDCEFrame, isRegionNormalPreset, isPresetRegion } from "../utils";
import { Howl } from 'dm-howler';

/** @ignore */
declare var ENV: any;
/**
 * A class dedicated to image recognizing.
 * ```js
 * let recognizer = await Dynamsoft.DLR.LabelRecognizer.createInstance({runtimeSettings: 'image'});
 * let results = await recognizer.recognize(imageSource);
 * for(let result of results){
 *     for(let lineResult of result.lineResults){
 *         console.log(lineResult.text);
 *     }
 * }
 * ```
 * ```js
 * let scanner = await Dynamsoft.DLR.LabelRecognizer.createInstance({runtimeSettings: 'numberLetter'});
 * scanner.onImageRead = results => console.log(results);
 * scanner.onUniqueRead = (txt, lineResult) => alert(txt);
 * scanner.startScanning(true);
 * ```
 */
export default class LabelRecognizer{
    private static _jsVersion = ENV.version;
    private static _jsEditVersion = ENV.modifiyVersion;
    private static _version = "loading...(JS " + LabelRecognizer._jsVersion + '.' + LabelRecognizer._jsEditVersion + ")";
    /**
     * Get the current version.
     */
    public static getVersion(){ return this._version; }

    private static _license = licenseGetFromScriptTag;
    /**
     * Set the Dynamsoft Label Recognizer SDK license.
     * ```js
     * Dynamsoft.DLR.LabelRecognizer.license = "LICENSE";
     * ```
     * For convenience, you can set `license` in `script` tag instead.
     * ```html
     * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-label-recognizer@2.2.30/dist/dlr.js" data-license="LICENSE"></script>
     * ```
     */
    public static get license(){ return this._license; }
    public static set license(license:string) { 
        setLicense(LabelRecognizer, license);
    }
    
    public static initLicense(license:string) {
        LabelRecognizer.license = license;
    }

    private static _sessionPassword = sessionPasswordFromScriptTag;
    /**
     * Specify a password to protect the `online key` from abuse.
     * ```js
     * Dynamsoft.DLR.LabelRecognizer.license = "123****-mytest";
     * Dynamsoft.DLR.LabelRecognizer.sessionPassword = "@#$%****";
     * ```
     * Since js in the browser is plaintext, it is not safe to set a password. It is recommended that you bind the `domain` as `Validation field` in the [handshake settings in dynamsoft website](https://www.dynamsoft.com/lts/index.html#/handshakeCodes) or your self-hosted license server. 
     * 
     * In nodejs, password is meaningful.
     * @see [[license]]
     */
    public static set sessionPassword(value:string){
        setSessionPassword(LabelRecognizer, value);
    }
    public static get sessionPassword(){
        return this._sessionPassword;
    }

    /**
     * modify from https://gist.github.com/2107/5529665
     * @ignore
     */
    public static browserInfo:any = browserInfo;

    /**
     * Detect environment and get a report.
     */
    public static async detectEnvironment(): Promise<any>{
        return await detectEnvironmentForDbrjsLikeProject();
    }

    private static _pLoad = new MutablePromise<void>();

    /** @ignore */
    public static _workerName:string = `dlr-${LabelRecognizer._jsVersion}.${bNode?'node':'browser'}.worker.js`; //todo

    private static _engineResourcePath?:string = curScriptDir;
    public static get engineResourcePath(){ return this._engineResourcePath; }

    /**
     * The SDK will try to automatically explore the engine location. 
     * If the auto-explored engine location is not accurate, manually specify the engine location.
     * ```js
     * Dynamsoft.DLR.LabelRecognizer.engineResourcePath = "https://cdn.jsdelivr.net/npm/dynamsoft-label-recognizer@2.2.30/dist/";
     * await Dynamsoft.DLR.LabelRecognizer.loadWasm();
     * ```
    */
    public static set engineResourcePath(value:string) {
        if(this._pLoad.isEmpty){
            LabelRecognizer._engineResourcePath = getAbsoluteDir(value);
        }else{
            throw new Error("`engineResourcePath` is not allowed to change after `createInstance` or `loadWasm` is called.");
        }
    }
    /** @ignore */
    private static _licenseServer?:string[] = [];
    public static get licenseServer(){ return this._licenseServer; }
    /**
     * Specify the license server URL.
    */
    public static set licenseServer(value:string[]|string){
        setLicenseServer(LabelRecognizer, value);
    }
    private static _deviceFriendlyName:string = "";
    /** @ignore */
    public static get deviceFriendlyName(){ return this._deviceFriendlyName; }
    /** @ignore */
    public static set deviceFriendlyName(value:string){
        setDeviceFriendlyName(LabelRecognizer, value);
    }
  
    /** @ignore */
    public static _onLog: (message: any) => void;
    /** @ignore */
    public static _bWasmDebug = false;

    /** @ignore */
    public static _dlrWorker: Worker;
    private static _nextTaskID = 0;
    private static _taskCallbackMap = new Map<number, (body: any) => void>();

    /** 
     * Fire when resources start loading.
     * @see [[onResourcesLoadProgress]]
     * @see [[onResourcesLoaded]]
     * @param resourcesPath The path of resources 
     */
    public static onResourcesLoadStarted:(resourcesPath?:string)=>void = null;
    /** 
     * Fire when resources progress.
     * @see [[onResourcesLoadStarted]]
     * @see [[onResourcesLoaded]]
     * @param resourcesPath The path of resources 
     * @param progress The download progress of resources 
     */
    public static onResourcesLoadProgress:(resourcesPath?:string, progress?:{ loaded:number, total:number })=>void = null;
    /** 
     * Fire when resources loaded.
     * @see [[onResourcesLoadStarted]]
     * @see [[onResourcesLoadProgress]]
     * @param resourcesPath The path of resources 
     */
    public static onResourcesLoaded:(resourcesPath?:string)=>void = null;

    /** @ignore */
    public _instanceID:number = undefined;

    private oriCanvas?:HTMLCanvasElement = null;//todo: re use canvas
    /** @ignore */
    private oriCanvasData?:any = null;
    
    /**
     * Whether to save the original image into canvas. 
     * ```js
     * recognizer.ifSaveOriginalImageInACanvas = true;
     * let results = await recognizer.recognize(source);
     * document.body.append(recognizer.getOriginalImageInACanvas());
     * ```
     */
    private _ifSaveOriginalImageInACanvas:boolean = false;
    public get ifSaveOriginalImageInACanvas(){
        return this._ifSaveOriginalImageInACanvas;
    }
    public set ifSaveOriginalImageInACanvas(value){
        this._ifSaveOriginalImageInACanvas = value;
    }
    /**
     * The original canvas.
     * ```js
     * recognizer.ifSaveOriginalImageInACanvas = true;
     * let results = await recognizer.recognize(source);
     * document.body.append(recognizer.oriCanvas);
     * ```
     */
     public getOriginalImageInACanvas(){
        if(!this.oriCanvas && this.oriCanvasData) {
            return this.oriCanvasData.toCanvas();
        }
        return this.oriCanvas;
    }

    private canvas:HTMLCanvasElement = null;

    private _region?:DLRReferenceRegion = null;
    private set region(value:null|DLRReferenceRegion){
        this._region = value;
    }
    private get region(){
        return this._region;
    }

    /** @ignore */
    public _timeStartRecognize:any = null;
    /** @ignore */
    public _timeEnterInnerDLR:any = null;

    private recognizeRecords:any = {};
    private drawRegionsultRecords:any = {};

    /**
     * Determine if the decoding module has been loaded successfully.
     * @category Initialize and Destroy
     */
    static isWasmLoaded(): boolean{
        return this._pLoad.isFulfilled;
    }

    private bDestroyed: boolean = false;
    /**
     * Indicates whether the instance has been destroyed.
     */
    public isContextDestroyed(){
        return this.bDestroyed;
    }

    /** @ignore */
    private _setWarnnedEx = new Set<string>();
    /** @ignore */
    private static _lastErrorCode = 0;
    /** @ignore */
    public static get lastErrorCode(){
        return this._lastErrorCode;
    }
    /** @ignore */
    private static _lastErrorString = "";
    /** @ignore */
    public static get lastErrorString(){
        return this._lastErrorString;
    }

    /** @ignore */
    private _lastErrorCode = 0;
    /** @ignore */
    public get lastErrorCode(){
        return this._lastErrorCode;
    }
    /** @ignore */
    private _lastErrorString = "";
    /** @ignore */
    public get lastErrorString(){
        return this._lastErrorString;
    }
    /** @ignore */
    public _lastInnerDecodeDuration = 0;

    /** @ignore */
    static recalculateResultLocation(results:any, sx:number, sy:number, sWidth:number, sHeight:number, dWidth:number, dHeight:number){
        if(results.length > 0 && results[0].lineResults.length > 0) {
            for(let dlrResult of results){
                for(let lineResult of dlrResult.lineResults){
                    let p = lineResult.location.points;
                    let wRate = dWidth / sWidth;
                    let hRate = dHeight / sHeight;
                    p[0].x = p[0].x / wRate + sx;
                    p[1].x = p[1].x / wRate + sx;
                    p[2].x = p[2].x / wRate + sx;
                    p[3].x = p[3].x / wRate + sx;
                    p[0].y = p[0].y / hRate + sy;
                    p[1].y = p[1].y / hRate + sy;
                    p[2].y = p[2].y / hRate + sy;
                    p[3].y = p[3].y / hRate + sy;
                }
            }
        }
    }

    //==================================== scanner related ===========================================

    /**
     * @deprecated
     */
    private static _defaultUIElementURL:string = "@engineResourcePath/dlr.ui.html";
    /**
     * @deprecated
     */
    public static get defaultUIElementURL():string{
        return this._defaultUIElementURL?.replace("@engineResourcePath/", LabelRecognizer.engineResourcePath);
    }
    /**
     * The url of the default scanner UI.
     * Can only be changed before `createInstance`.
     * ```js
     * Dynamsoft.DLR.LabelRecognizer.defaultUIElementURL = "https://cdn.jsdelivr.net/npm/dynamsoft-label-recognizer@2.2.30/dist/dlr.ui.html";
     * let pScanner = null;
     * (async()=>{
     *     let scanner = await (pScanner = pScanner || Dynamsoft.DLR.LabelRecognizer.createInstance());
     *     await scanner.startScanning(true);
     * })();
     * ```
     */
    public static set defaultUIElementURL(value: string){
        this._defaultUIElementURL = value;
    }
  
    /** @ignore */
    intervalTime: number = 0;
    //duplicateForgetTime: number = 3000;

    /** @ignore */
    private _intervalGetVideoFrame:number = 0;

    private _loopReadVideoTimeoutId:any;

    private _vinResultArrayTimeoutId: any;

    private _idCardUpperLine: string = "";

    /** @ignore */
    private array_getFrameTimeCost:any[] = [];
    /** @ignore */
    private array_decodeFrameTimeCost:any[] = [];

    private _dlrDrawingLayer:any;

    private _arrPolygons:any = [];

    private _bPauseScan:boolean = false;
    private _intervalDetectVideoPause = 1000;

    protected captureAndRecognizeInParallel:boolean = true;

    /** @ignore */
    public _selMinLtr:any = null;
    /** @ignore */
    public _optGotMinLtr:any = null;

    private _minLetter = 0;
    private _updateMinLtrSel(minLetter: number){
        this._minLetter = minLetter;
        if(this._optGotMinLtr){
            const gotMinLtr = minLetter ? `${minLetter}+ letters` : 'any letter';
            this._optGotMinLtr.innerText = gotMinLtr;
            if(this._selMinLtr && this._optGotMinLtr.parentNode == this._selMinLtr){
                this._selMinLtr.value = 'got';
            }
        }
    }

    /** @ignore */
    private _soundSource: string = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAABQAAAkAAgICAgICAgICAgICAgICAgICAgKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg4ODg4P//////////////////////////AAAAAExhdmM1OC41NAAAAAAAAAAAAAAAACQEUQAAAAAAAAJAk0uXRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+MYxAANQAbGeUEQAAHZYZ3fASqD4P5TKBgocg+Bw/8+CAYBA4XB9/4EBAEP4nB9+UOf/6gfUCAIKyjgQ/Kf//wfswAAAwQA/+MYxAYOqrbdkZGQAMA7DJLCsQxNOij///////////+tv///3RWiZGBEhsf/FO/+LoCSFs1dFVS/g8f/4Mhv0nhqAieHleLy/+MYxAYOOrbMAY2gABf/////////////////usPJ66R0wI4boY9/8jQYg//g2SPx1M0N3Z0kVJLIs///Uw4aMyvHJJYmPBYG/+MYxAgPMALBucAQAoGgaBoFQVBUFQWDv6gZBUFQVBUGgaBr5YSgqCoKhIGg7+IQVBUFQVBoGga//SsFSoKnf/iVTEFNRTMu/+MYxAYAAANIAAAAADEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
    public beepSound:Howl = !bNode && new Howl({
        src: [this._soundSource],
        onplayerror: (id, err)=>{
            console.warn(`Sound '${id}' playback failure: ${err}`);
        }
    });

    private get soundSource():string{ return this._soundSource; }
    private set soundSource(value:string){ 
        this._soundSource = value;
        this.beepSound = new Howl({
            src: [this._soundSource],
            onplayerror: (id, err)=>{
                console.warn(`Sound '${id}' playback failure: ${err}`);
            }
        });
    }

    /**
     * Whether to play sound when the scanner reads a character line successfully.
     * Default value is `false`, which does not play sound.
     * Use `frame` or `true` to play a sound when any character line is found within a frame.
     * Use `unique` to play a sound only when any unique/unduplicated character line is found within a frame.
     * ```js
     * // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
     * startPlayButton.addEventListener('click', function() {
     *   scanner.bPlaySoundOnSuccessfulRead = false;
     *   scanner.bPlaySoundOnSuccessfulRead = true;
     *   scanner.bPlaySoundOnSuccessfulRead = "frame";
     *   scanner.bPlaySoundOnSuccessfulRead = "unique";
     * });
     * ```
     * refer: `favicon bug` https://bugs.chromium.org/p/chromium/issues/detail?id=1069731&q=favicon&can=2
     */
    private bPlaySoundOnSuccessfulRead:(boolean|string) = false;
    
    private get whenToPlaySoundforSuccessfulRead(){
        if(true === this.bPlaySoundOnSuccessfulRead){
            return "frame";
        }else if(this.bPlaySoundOnSuccessfulRead){
            return this.bPlaySoundOnSuccessfulRead; // frame, unique
        }else{
            return "never";
        }
    }
    /**
     * Whether to vibrate when the scanner reads a character line successfully.
     * Default value is `false`, which does not vibrate.
     * Use `frame` or `true` to play a sound when any character line is found within a frame.
     * Use `unique` to play a sound only when any unique/unduplicated character line is found within a frame.
     * ```js
     * // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
     * startPlayButton.addEventListener('click', function() {
     *   scanner.bVibrateOnSuccessfulRead = false;
     *   scanner.bVibrateOnSuccessfulRead = true;
     *   scanner.bVibrateOnSuccessfulRead = "frame";
     *   scanner.bVibrateOnSuccessfulRead = "unique";
     * });
     * ```
     * refer: `favicon bug` https://bugs.chromium.org/p/chromium/issues/detail?id=1069731&q=favicon&can=2
     */
    // public bVibrateOnSuccessfulRead:(boolean|string) = false;
    private set whenToPlaySoundforSuccessfulRead(value: string){
        if("never" === value){
            this.bPlaySoundOnSuccessfulRead = false;
        }else{
            this.bPlaySoundOnSuccessfulRead = value;
        }
    }
    /**
     * Whether to vibrate when the scanner reads a barcode successfully.
     * Default value is `false`, which does not vibrate.
     * Use `frame` or `true` to vibrate when any barcode is found within a frame.
     * Use `unique` to vibrate only when any unique/unduplicated barcode is found within a frame.
     * ```js
     * // Can I use? https://caniuse.com/?search=vibrate
     * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
     * startVibrateButton.addEventListener('click', function() {
     *   scanner.bVibrateOnSuccessfulRead = true;
     * });
     * ```
     * @ignore
     */
    private bVibrateOnSuccessfulRead:(boolean|string) = false;
    /**
     * Get or set how long (ms) the vibration lasts.
     * @see [[whenToVibrateforSuccessfulRead]]
     */
    private vibrateDuration = 300;

    private get whenToVibrateforSuccessfulRead(){
        if(true === this.bVibrateOnSuccessfulRead){
            return "frame";
        }else if(this.bVibrateOnSuccessfulRead){
            return this.bVibrateOnSuccessfulRead; // frame, unique
        }else{
            return "never";
        }
    }
    /**
     * Whether to vibrate when the scanner reads a barcode successfully.
     * Default value is `never`, which does not vibrate.
     * Use `frame` to vibrate when any barcode is found within a frame.
     * Use `unique` to vibrate only when any unique/unduplicated barcode is found within a frame.
     * ```js
     * // Can I use? https://caniuse.com/?search=vibrate
     * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
     * startPlayButton.addEventListener('click', function() {
     *   scanner.whenToVibrateforSuccessfulRead = 'frame';
     * });
     * ```
     */
    private set whenToVibrateforSuccessfulRead(value: string){
        if("never" === value){
            this.bVibrateOnSuccessfulRead = false;
        }else{
            this.bVibrateOnSuccessfulRead = value;
        }
    }

    /**
     * @category UI
     */
    public highlightFillStyle = "rgba(254,180,32,0.3)";
    /**
     * @category UI
     */
    public highlightStrokeStyle = "rgba(254,180,32,0.9)";

    private _vinResultArray: Array<string> = [];

    private currentSettingsTemplate: string = "cppdefault";

    private _dce:CameraEnhancer = null;
    private set dce(value:CameraEnhancer) {
        this._dce = value;
    }
    private get dce():CameraEnhancer {
        if(!this._dce || this._dce.isDisposed) return null;

        return this._dce;
    }

    private _drawingItemNamespace:any;

    private _dceControler:any;

    private imgSource:ImageSource = null;

    private callbackCameraChange?:()=>void;

    private callbackResolutionChange?:()=>void;

    private callbackCameraClose?:()=>void;

    private callbackSingleFrameAcquired?:(dceFrame:DCEFrame)=>void;

    private _maxCvsSideLength:number = ["iPhone", "Android", "HarmonyOS"].includes(LabelRecognizer.browserInfo.OS) ? 2048 : 4096;
    /** @ignore */
    public set maxCvsSideLength(value:number) {
        this._maxCvsSideLength = value;
        if(this._dceControler) {
            this._dceControler.setDisiredValue(this, "maxCvsSideLength", value);
        }
    }
    public get maxCvsSideLength():number {
        return this._maxCvsSideLength;
    }
    private presetVideoTemplateRegion:any = {
        regionLeft: 0,
        regionRight: 100,
        regionTop: 40,
        regionBottom: 60,
        regionMeasuredByPercentage: true
    }

    private async _registerDCEControler():Promise<void> {
        if(!this.dce) return;
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_registerDCEControler()');

        const cameraEnhancer = this.dce;
        this._dceControler = cameraEnhancer._createControler();
        const controler = this._dceControler;
        controler.register(this);
        controler.setDisiredValue(this, "refreshInterval", 200);
        controler.setDisiredValue(this, "maxCvsSideLength", this._maxCvsSideLength);

        // delete when unnecessary to be compatible with dce 3.0.0
        try{
            if(ResizeObserver) {}
        } catch(e) {
            if(e.name === "ReferenceError") {
                window&&(window.ResizeObserver = undefined);
            }
        }
        
        const ui = cameraEnhancer.getUIElement();
        const dceClass = this.dce.constructor as any;
        // Try to change UI intelligently.
        if(dceClass._defaultUIElementURL === "@engineResourcePath/dce.ui.html") {
            try{
                if(ui) {
                    if(ui === controler._innerSetUI) {
                        // the current ui is set by other productions, change it.
                        await cameraEnhancer.setUIElement(`${dceClass.engineResourcePath}dce.ui.html`);
                        controler._innerSetUI = cameraEnhancer.getUIElement();
                    }
                } else {
                    await cameraEnhancer.setUIElement(`${dceClass.engineResourcePath}dlr.ui.html`);
                    controler._innerSetUI = cameraEnhancer.getUIElement();
                }
            } catch(e) {
                await cameraEnhancer.setUIElement(dceClass.defaultUIElementURL);

            }
        } else {
            if(!ui) {
                await cameraEnhancer.setUIElement(dceClass.defaultUIElementURL);
            }
        }
            
        // add some callbacks
        this.callbackCameraChange = ()=>{
            // make frame queue empty
            // this.queue_handledFrame.length = 0;
            this._drawResults(null);
            this.array_decodeFrameTimeCost.length = 0;
            this.array_getFrameTimeCost.length = 0;
            this._intervalGetVideoFrame = 0;
        };
    
        this.callbackResolutionChange = ()=>{
            // make frame queue empty
            // this.queue_handledFrame.length = 0;
            this._drawResults(null);
            this.array_decodeFrameTimeCost.length = 0;
            this.array_getFrameTimeCost.length = 0;
            this._intervalGetVideoFrame = 0;
        };
    
        this.callbackCameraClose = ()=>{
            this.stopScanning(true);
            this.array_decodeFrameTimeCost.length = 0;
            this.array_getFrameTimeCost.length = 0;
            this._intervalGetVideoFrame = 0;
            this._bPauseScan = false;
        };
    
        this.callbackSingleFrameAcquired = async(dceFrame:DCEFrame)=>{
            let results = await this._recognize_DCEFrame(dceFrame, {bCopyData:false});
            let locations = null;
            if(results && results.length) {
                const {sx, sy, width, height, _sWidth, _sHeight} = dceFrame;
                locations = results.map(result=>{
                    return {
                        lineResults: result.lineResults.map(lineResult=>{
                            return {
                                location: JSON.parse(JSON.stringify(lineResult.location))
                            };
                        })
                    };
                });
                LabelRecognizer.recalculateResultLocation(locations, sx, sy, _sWidth, _sHeight, width, height);
            }
            this._drawResults(locations);
            await this.clearMapDecodeRecord();
            for(let result of results){
                delete (result as any).bUnduplicated;
            }
            if(this.onImageRead && this.dce.isOpen() && !this._bPauseScan){
                let clonedResults = this._cloneDecodeResults(results);
                this.onImageRead(clonedResults);
            }
            if(this.onUniqueRead && this.dce.isOpen() && !this._bPauseScan){
                for(let dlrResult of results){
                    for(let lineResult of dlrResult.lineResults){
                        this.onUniqueRead(lineResult.text, this._cloneDecodeResults(lineResult));
                    }
                }
            }
            if(this.onMRZRead && this.dce.isOpen() && !this._bPauseScan){
                const mrzRelatedTemplateList = ["MRZ", "passportMRZ", "visaMRZ", "idcardMRZ"];
                // When current template is related mrz, combine multi-row result text to single row result text
                if(mrzRelatedTemplateList.includes(this.currentSettingsTemplate)) {
                    let res = this._cloneDecodeResults(results)
                    this._filterVideoModeMrzResult(res);
                }
            }
            if(this.onVINRead && this.dce.isOpen() && !this._bPauseScan) {
                const vinRelatedTemplateList = ["VIN", "VIN_NA"];
                if(vinRelatedTemplateList.includes(this.currentSettingsTemplate)) {
                    let clonedResults = this._cloneDecodeResults(results);
                    if(clonedResults.length) {
                        let resultStr = "";
                        for(let dlrResult of clonedResults) {
                            for(let dlrLineResult of dlrResult.lineResults) {
                                if(dlrLineResult.characterResults.length === 18) {
                                    const leftCon = dlrLineResult.characterResults[0].characterHConfidence;
                                    const rightCon = dlrLineResult.characterResults[17].characterHConfidence;
                                    leftCon > rightCon ? dlrLineResult.characterResults.pop() : dlrLineResult.characterResults.shift();
                                } else if(dlrLineResult.characterResults.length === 19) {
                                    let leftCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[1].characterHConfidence;
                                    let rightCon = dlrLineResult.characterResults[17].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                                    let leftRightCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                                    let minValue = Math.min(leftCon, rightCon, leftRightCon);
                                    if(minValue === leftCon) {
                                        dlrLineResult.characterResults.splice(0,2);
                                    } else if(minValue === rightCon) {
                                        dlrLineResult.characterResults.splice(17,2);
                                    } else if(minValue === leftRightCon) {
                                        dlrLineResult.characterResults.pop();
                                        dlrLineResult.characterResults.shift();
                                    }
                                }
                                for(let oneChar of dlrLineResult.characterResults) {
                                    resultStr += oneChar.characterH;
                                }
                                this.onVINRead(resultStr, results[0].lineResults[0]);
                            }
                        }
                    }
                }
            }
        };

        cameraEnhancer.on("cameraChange", this.callbackCameraChange);
        cameraEnhancer.on("resolutionChange", this.callbackResolutionChange);
        cameraEnhancer.on("cameraClose", this.callbackCameraClose);
        cameraEnhancer.on("singleFrameAcquired", this.callbackSingleFrameAcquired);
    }

    private _logoutDCEControler():void {
        if(!this.dce || !this._dceControler) return;
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_logoutDCEControler()');

        this._dceControler.logout(this);
        this.dce.off("cameraChange", this.callbackCameraChange);
        this.dce.off("resolutionChange", this.callbackResolutionChange);
        this.dce.off("cameraClose", this.callbackCameraClose);
        this.dce.off("singleFrameAcquired", this.callbackSingleFrameAcquired);
        // relase layer
        this._dceControler = null;
        this._dlrDrawingLayer = null;
        this.dce = null;
    }

    public async setImageSource(imgSource: ImageSource | CameraEnhancer, options?:any):Promise<void> {
        if(bNode) throw new Error("`setImageSource` is not supported in Node.js.");
        // reset imageSource and dce
        if(imgSource == null) {
            this.imgSource = null;
            this._logoutDCEControler();
            this._drawingItemNamespace = null;
            return;
        }
        if(imgSource && (imgSource as any).isCameraEnhancer) {
            this.dce = imgSource as CameraEnhancer;
            await this._registerDCEControler();
            this.imgSource = null;
        } else if(isImageSource(imgSource)){
            this._logoutDCEControler();
            this.imgSource = imgSource as ImageSource;
        } else {
            throw new Error(`Invalid value.`);
        }
        if(options) {
            if(options.resultsHighlightBaseShapes) {
                this._drawingItemNamespace = options.resultsHighlightBaseShapes;
            }
        }
    }

    /**
     * Manually load and compile the decoding module. Used for preloading to avoid taking too long for lazy loading.
     * @category Initialize and Destroy
     */
    static async loadWasm(): Promise<void>{
        if(this._pLoad.isEmpty){
            let { 
                lt, // licenseType 
                l, // license
                ls, // licenseServer
                sp, // sessionPassword
                rmk, // remark
            } = preProcessLicense(LabelRecognizer);

            this._pLoad.task = async(rs,rj)=>{
                let workerUrl = LabelRecognizer.engineResourcePath + LabelRecognizer._workerName;
                // If the script and page are same origin, the script can load directly from the url
                if(!bNode && !LabelRecognizer.engineResourcePath.startsWith(location.origin)){
                    // Otherwise, cross domain, need get blob, then use objectUrl
                    workerUrl = await fetch(workerUrl).then(responese=>responese.blob()).then(blob=>URL.createObjectURL(blob));
                }
                if(!bNode){
                    LabelRecognizer._dlrWorker = new Worker(workerUrl);
                }else{
                    const { Worker } = await import('node:worker_threads');
                    LabelRecognizer._dlrWorker = (new Worker(workerUrl) as any as Worker);
                }

                LabelRecognizer._dlrWorker.onerror = (e) => {
                    let ex = new Error(e.message);
                    rj(ex);
                };
                
                LabelRecognizer._dlrWorker.onmessage = async e => {
                    let data = e.data ? e.data : e;
                    let type = data.type;
                    
                    switch(type){
                        case "log": {
                            if(LabelRecognizer._onLog)LabelRecognizer._onLog(data.message);
                            break;
                        }
                        case "load":{
                            if(data.message){ data.message = data.message.replace("(https://www.dynamsoft.com/purchase-center/)","(https://www.dynamsoft.com/store/dynamsoft-label-recognizer/#javascript)"); }
                            let bNeedShowDialog = false;
                            if(1 === lt){
                                bNeedShowDialog = true;
                            }

                            let ex:Error;
                            if(data.success){
                                LabelRecognizer._dlrWorker.onerror = null;

                                LabelRecognizer._version = data.version + "(JS " + LabelRecognizer._jsVersion + '.' + LabelRecognizer._jsEditVersion + ")";
                                if(LabelRecognizer._onLog)LabelRecognizer._onLog('load dlr worker success');

                                if(data.message){
                                    console.warn(data.message);
                                }
                            }else{
                                ex = new Error(data.message);
                                ex.stack = data.stack + '\n' + ex.stack;
                                if(!bNeedShowDialog){
                                    // `error code: 111` need to match ltsjs's logic
                                    if(111 == data.ltsErrorCode && -1 != data.message.toLowerCase().indexOf('trial license')){
                                        bNeedShowDialog = true;
                                    }
                                }
                            }

                            if(bNeedShowDialog){
                                LabelRecognizer.showDialog(data.success?"warn":"error",data.message);
                            }

                            data.success ? rs(): rj(ex);
                            // if(!LabelRecognizer._bLoadWorkerDirectlyFromUrl){
                            //     // release objectUrl
                            //     URL.revokeObjectURL(workerUrl);
                            // }
                            break;
                        }
                        case "task": {
                            let taskID = data.id;
                            let body = data.body;
                            try{
                                LabelRecognizer._taskCallbackMap.get(taskID)(body);
                                LabelRecognizer._taskCallbackMap.delete(taskID);
                            }catch(ex){
                                LabelRecognizer._taskCallbackMap.delete(taskID);
                                throw ex;
                            }
                            break;
                        }
                        case "event": {
                            if(data.body.type === "resourcesLoadStarted") {
                                LabelRecognizer.onResourcesLoadStarted&&setTimeout(()=>LabelRecognizer.onResourcesLoadStarted(data.body.resourcesPath), 0);
                            } else if(data.body.type === "resourcesLoadProgress") {
                                LabelRecognizer.onResourcesLoadProgress&&setTimeout(()=>LabelRecognizer.onResourcesLoadProgress(data.body.resourcesPath, {
                                    loaded: data.body.loaded,
                                    total: data.body.total,
                                }), 0);
                            } else if(data.body.type === "resourcesLoaded") {
                                LabelRecognizer.onResourcesLoaded&&setTimeout(()=>LabelRecognizer.onResourcesLoaded(data.body.resourcesPath), 0);
                            }
                            break;
                        }
                        default: {
                            if(LabelRecognizer._onLog)LabelRecognizer._onLog(e);
                            break;
                        }
                    }
                };
                if (bNode) (LabelRecognizer._dlrWorker as any).on('message', LabelRecognizer._dlrWorker.onmessage);
                // todo: make it unreadable
                LabelRecognizer._dlrWorker.postMessage({
                    type:"loadWasm",
                    engineResourcePath: LabelRecognizer.engineResourcePath,
                    bd: LabelRecognizer._bWasmDebug,
                    v: LabelRecognizer._jsVersion,
                    // bRuntimeKey
                    brtk: !!lt,
                    // bPublicTryKey
                    bptk: 1 === lt,
                    l, // license
                    dm: ((!bNode)&&location.origin.startsWith("http")?location.origin:"https://localhost"),
                    os: browserInfo,
                    fn: LabelRecognizer.deviceFriendlyName,
                    ls, // licenseServer,
                    sp, // sessionPassword,
                    rmk,
                });
                // not break; continue to case 'loading'
            };
        }

        await this._pLoad;
    }

    /**
     * @param type "warn" or "error"
     * @param content 
     * @returns 
     */
    private static async showDialog(type: string, content: string):Promise<void>{
        await showDialog(this, type, content);
    }

    private static async createInstanceInWorker(): Promise<number>{
        await this.loadWasm();
        return await new Promise((resolve, reject) => {
            let taskID = this._nextTaskID++;
            this._taskCallbackMap.set(taskID, (body: any) =>{
                if(body.success){
                    return resolve(body.instanceID);
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            this._dlrWorker.postMessage({
                type: "createInstance",
                id: taskID,
                bScanner: false,
            });
        });
    }

    private constructor(){}

    /**
    * Create a `LabelRecognizer` object.
    * ```
    * let recognizer = await Dynamsoft.DLR.LabelRecognizer.createInstance();
    * ```
     * @category Initialize and Destroy
    */
    static async createInstance(config?: any): Promise<LabelRecognizer>{
        let recognizer = new LabelRecognizer();
        recognizer._instanceID = await this.createInstanceInWorker();
        // {runtimeSettings: 'image'}
        if(config && config.runtimeSettings){
            recognizer.updateRuntimeSettingsFromString(config.runtimeSettings);
        }
        return recognizer;
    }

    /**
     * The main recognizing method can accept a variety of data types, including binary data, images, base64(with mime), urls, etc.
     * ```js
     * let results = await recognizer.recognize(blob);
     * for(let result of results){
     *     for(let lineResult of result.lineResults){
     *         console.log(lineResult.text);
     *     }
     * }
     * ```
     * @param source 
     * @category Recognize
     */
    async recognize(source: Blob | Buffer | ArrayBuffer | Uint8Array | Uint8ClampedArray | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | string | DCEFrame | DSImage, config?: any): Promise<DLRResult[]> {
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('recognize(source: any, modelName?: string)');
        if(LabelRecognizer._onLog)this._timeStartRecognize = Date.now();
        config = config||{};
        let results:any;
        if(!bNode){
            if(source instanceof Blob){
                results = await this._recognize_Blob(source, config);
            }
            else if(source instanceof ArrayBuffer){
                results = await this._recognize_ArrayBuffer(source, config);
            }
            else if((source instanceof Uint8Array)||(source instanceof Uint8ClampedArray)){
                results = await this._recognize_Uint8Array(source, config);
            }
            else if(source instanceof HTMLImageElement || typeof ImageBitmap != "undefined" && source instanceof ImageBitmap){
                results = await this._recognize_Image(source, config);
            }
            else if(source instanceof HTMLCanvasElement){
                results = await this._recognize_Canvas(source, config);
            }
            else if(source instanceof HTMLVideoElement){
                results = await this._recognize_Video(source, config);
            }
            else if(typeof source == 'string'){
                if(source.substring(0, 11) == "data:image/"){
                    results = await this._recognize_Base64(source, config);
                }
                else{
                    results = await this._recognize_Url(source, config);
                }
            } else if(isDCEFrame(source)) {
                config.bCopyData = true;
                results = await this._recognize_DCEFrame(source as DCEFrame, config);
            } else if(isDSImage(source)) {
                config.bCopyData = true;
                results = await this._recognize_DSImage(source as DSImage, config);
            } else{
                results = await Promise.reject(TypeError("'_recognize(source, config)': Type of 'source' should be 'Blob', 'ArrayBuffer', 'Uint8Array', 'HTMLImageElement', 'HTMLCanvasElement', 'HTMLVideoElement', 'string(base64 with image mime)', 'string(url)' or 'object(dceFrame)'."));
            }
        }else{
            if(source instanceof Buffer){
                results = await this._recognizeFileInMemory_Uint8Array(new Uint8Array(source), config);
            }else if(source instanceof Uint8Array){
                results = await this._recognizeFileInMemory_Uint8Array(source, config);
            }else if(typeof source == 'string'){
                if((source as string).substring(0, 11) == "data:image/"){
                    results = await this._recognize_Base64(source, config);
                }
                else if((source as string).substring(0, 4) == "http"){
                    results = await this._recognize_Url(source, config);
                }else{
                    results = await this._recognize_FilePath(source, config);
                }
            }else{
                return await Promise.reject(TypeError("'_recognize(source, config)': Type of 'source' should be 'Buffer', 'Uint8Array', 'string(base64 with image mime)' or 'string(url)'."));
            }
        }
        return this._filterResult(results) || results;
    };

    /**
     * The recognizing method can accept base64 with or without mime.
     * e.g. `data:image/jpg;base64,Xfjshekk....` or `Xfjshekk...`.
     * ```js
     * let results = await recognizer.recognizeBase64String(strBase64);
     * for(let result of results){
     *     for(let lineResult of result.lineResults){
     *         console.log(lineResult.text);
     *     }
     * }
     * ```
     * @param base64 
     * @category Recognize
     */
    async recognizeBase64String(base64: string, modelName?: string): Promise<DLRResult[]> {
        let config:any = {};
        if(modelName){ config.modelName = modelName; }
        let results: any = await this._recognize_Base64(base64, config);
        return this._filterResult(results) || results;
    }

    /**
     * The decoding method can accept url. The url source need to be in the same domain or allowed cors.
     * ```js
     * let results = await recognizer.recognizeUrl("./1.png");
     * for(let result of results){
     *     for(let lineResult of result.lineResults){
     *         console.log(lineResult.text);
     *     }
     * }
     * ```
     * @param url 
     * @category Recognize
     */
    async recognizeUrl(url: string, modelName?: string): Promise<DLRResult[]> {
        let config:any = {};
        if(modelName){ config.modelName = modelName; }
        let results: any = await this._recognize_Url(url, config);
        return this._filterResult(results) || results;
    }

    /**
     * Recognize from raw buffer.
     * @param buffer 
     * @param width 
     * @param height 
     * @param stride 
     * @param format 
     * @param config 
     * @category Recognize
     */
    async recognizeBuffer(buffer: Uint8Array|Uint8ClampedArray|ArrayBuffer|Blob|Buffer,width: number, height: number,stride: number,format: EnumDLRImagePixelFormat, config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('recognizeBuffer(buffer,width,height,stride,format)');
        if(LabelRecognizer._onLog)this._timeStartRecognize = Date.now();
        
        let results: any;
        if(!bNode){
            if(buffer instanceof Uint8Array || buffer instanceof Uint8ClampedArray){
                results = await this._recognizeBuffer_Uint8Array(buffer,width,height,stride,format,config);
            }
            else if(buffer instanceof ArrayBuffer){
                results = await this._recognizeBuffer_Uint8Array(new Uint8Array(buffer),width,height,stride,format,config);
            }
            else if(buffer instanceof Blob){
                results = await this._recognizeBuffer_Blob(buffer,width,height,stride,format,config);
            }
        }else{
            if(buffer instanceof Uint8Array){
                results = await this._recognizeBuffer_Uint8Array(buffer,width,height,stride,format,config);
            }else if(buffer instanceof Buffer){
                results = await this._recognizeBuffer_Uint8Array(new Uint8Array(buffer),width,height,stride,format,config);
            }
        }
        return this._filterResult(results) || results;
    }

    private _filterResult(results: any) {
        if(!results.length) return results;
        if(["MRZ", "passportMRZ", "visaMRZ", "idcardMRZ"].includes(this.currentSettingsTemplate)) {
            const res = this._filterMrzResult(results);
            res.length && this._verifyCheckDigit(res[0].lineResults);
            return res;
        }
        if(["VIN", "VIN_NA"].includes(this.currentSettingsTemplate)) {
            this._filterVinResult(results);
            results.length && this._verifyCheckDigit(results[0].lineResults);
        }
    }

    private _filterMrzResult(results: any) {
        let responese: any = [];
        if(results.length === 0) return [];
        for(let i=0;i<results.length;i++){
            responese.push(JSON.parse(JSON.stringify(results[i])));
            responese[i].lineResults = [];
            if(results[i].lineResults.length >= 2) { 
                if(results[i].lineResults[results[i].lineResults.length-1].text.length > 30 && results[i].lineResults.length >= 2) {
                    for(let j=results[i].lineResults.length-2;j<results[i].lineResults.length;j++) {
                        responese[i].lineResults.push(results[i].lineResults[j]);
                    }
                    return responese;
                } else if(results[i].lineResults[results[i].lineResults.length-1].text.length <= 30 && results[i].lineResults.length >= 3) {
                    for(let j=results[i].lineResults.length-3;j<results[i].lineResults.length;j++) {
                        responese[i].lineResults.push(results[i].lineResults[j]);
                    }
                    return responese;
                } else {
                    return [];
                }
            } else return [];
        }
    }

    private _filterVinResult(results: any) {
        let resultStr = "";
        if(results.length) {
            for(let dlrResult of results) {
                for(let dlrLineResult of dlrResult.lineResults) {
                    if(dlrLineResult.characterResults.length === 18) {
                        const leftCon = dlrLineResult.characterResults[0].characterHConfidence;
                        const rightCon = dlrLineResult.characterResults[17].characterHConfidence;
                        leftCon > rightCon ? dlrLineResult.characterResults.pop() : dlrLineResult.characterResults.shift();
                    } else if(dlrLineResult.characterResults.length === 19) {
                        let leftCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[1].characterHConfidence;
                        let rightCon = dlrLineResult.characterResults[17].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                        let leftRightCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                        let minValue = Math.min(leftCon, rightCon, leftRightCon);
                        if(minValue === leftCon) {
                            dlrLineResult.characterResults.splice(0,2);
                        } else if(minValue === rightCon) {
                            dlrLineResult.characterResults.splice(17,2);
                        } else if(minValue === leftRightCon) {
                            dlrLineResult.characterResults.pop();
                            dlrLineResult.characterResults.shift();
                        }
                    }
                    for(let oneChar of dlrLineResult.characterResults) {
                        resultStr += oneChar.characterH;
                    }
                    dlrLineResult.text = resultStr;
                }
            }
        }
    }

    private _verifyCheckDigit(results: any) {
        const mrzType: string = this._getMrzType(results);
        const lineNumber = results.length;
        if(lineNumber >= 3 && ["MRZ", "idcardMRZ"].includes(this.currentSettingsTemplate)) {
            this._idCardUpperLine = results[0].text;
        }
        const verifyCheckDigit = (text: string): boolean => {
            if(!text) return false;
            if(["MRZ", "passportMRZ"].includes(this.currentSettingsTemplate) && mrzType === "passport") {
                return !/[0-9]/.test(text) ? null : this._checkValidMRP(text);
            } else if(["MRZ", "idcardMRZ"].includes(this.currentSettingsTemplate) && mrzType === "idcard") {
                return !/[0-9]/.test(text) ? null : this._checkValidIDCard(text, this._idCardUpperLine);
            } else if(["MRZ", "visaMRZ"].includes(this.currentSettingsTemplate) && mrzType === "visa") {
                return !/[0-9]/.test(text) ? null : this._checkValidMRV(text);
            } else if(["VIN", "VIN_NA"].includes(this.currentSettingsTemplate)){
                return this._checkValidVIN(text);
            } else {
                return false;
            }
        }
        for(let lineResult of results) {
            lineResult.isCheckDigitMatched = verifyCheckDigit(lineResult.text);
        }
    }

    private _getMrzType(results: any): string {
        const textLength = results[0].text.length;
        const lineCount = results.length;
        const upperLineFirstChar = results[0].text[0];
        const bHaveACI = ["A","C","I"].includes(upperLineFirstChar);
        if(textLength === 44 && lineCount === 2 && upperLineFirstChar === "P") return "passport";
        if(textLength === 44 && lineCount === 2 && upperLineFirstChar === "V") return "visa";
        if(textLength === 36 && lineCount === 2 && upperLineFirstChar === "V") return "visa";
        if(textLength === 36 && lineCount === 2 && bHaveACI) return "idcard";
        if(textLength === 30 && lineCount === 3 && bHaveACI) return "idcard";
        return null;
    }
    
    /**
     * Recognize from the memory buffer containing image pixels in defined format.
     * @ignore
     */
    async _recognizeBuffer_Uint8Array(buffer: Uint8Array | Uint8ClampedArray,width: number, height: number, stride: number,format: EnumDLRImagePixelFormat, config?:any): Promise<DLRResult[]>{
        return await new Promise((resolve,reject) =>{
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body: any) =>{
                if(body.success){
                    let timeGetMessage = LabelRecognizer._onLog?Date.now():0;//debug
                    let results;
                    this._lastInnerDecodeDuration = body.duration;
                    try{
                        results = this._handleRetJsonString(body.decodeReturn);
                    }catch(ex){
                        return reject(ex);
                    }
                    if(LabelRecognizer._onLog){//debug
                        let timeAfterHandleResult = Date.now();
                        LabelRecognizer._onLog("DLR getting message from worker timestamp: "+(timeGetMessage));
                        LabelRecognizer._onLog("From DLR starting recognizing to entering worker costs: "+(this._timeEnterInnerDLR-this._timeStartRecognize));
                        LabelRecognizer._onLog("From DLR entering worker to returning message from worker costs: "+(timeGetMessage-this._timeEnterInnerDLR));
                        LabelRecognizer._onLog("Handling results from DBR worker costs: "+(timeAfterHandleResult-timeGetMessage));
                        LabelRecognizer._onLog("Total recognize image costs: "+(timeAfterHandleResult-this._timeStartRecognize));
                    }//debug
                    return resolve(results);
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            if(LabelRecognizer._onLog)this._timeEnterInnerDLR = Date.now();
            if(LabelRecognizer._onLog)LabelRecognizer._onLog("Sending buffer to worker timestamp:"+ this._timeEnterInnerDLR);// for debug
            LabelRecognizer._dlrWorker.postMessage({
                type:"recognizeByBuffer",
                "id":taskID,
                "instanceID":this._instanceID,
                body:{
                    config: config,
                    imageData: {
                        bytes: buffer,
                        length: stride*height,
                        width: width,
                        height: height,
                        stride: stride,
                        format: format
                    }
                }
            }, [buffer.buffer]);

            if(LabelRecognizer._onLog && config && config.timeStamp)LabelRecognizer._onLog('Delay of recognizing image: ' + (this._timeEnterInnerDLR - config.timeStamp));
        });
    }

    /**
     * 
     * @param buffer 
     * @param width 
     * @param height 
     * @param stride 
     * @param format 
     * @param config 
     * @ignore
     */
    async _recognizeBuffer_Blob(buffer: Blob,width: number, height: number, stride: number,format: EnumDLRImagePixelFormat, config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognizeBuffer_Blob(buffer,width,height,stride,format)');

        const arrayBuffer = buffer.arrayBuffer ? 
            await buffer.arrayBuffer() : 
            await new Promise<ArrayBuffer>((resolve, reject) => {
                let freader = new FileReader();
                freader.readAsArrayBuffer(buffer);
                freader.onload = () => {
                    resolve(freader.result as ArrayBuffer);
                };
                freader.onerror = () => {
                    reject(freader.error);
                };
            })
        ;
        return await this._recognizeBuffer_Uint8Array(new Uint8Array(arrayBuffer),width,height,stride,format,config);
    }

    /** @ignore */
    async _recognizeFileInMemory_Uint8Array(bytes: Uint8Array, config?: any): Promise<DLRResult[]>{
        return await new Promise((resolve,reject) =>{
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body: any) =>{
                if(body.success){
                    let results;
                    try{
                        results = this._handleRetJsonString(body.decodeReturn);
                    }catch(ex){
                        return reject(ex);
                    }
                    return resolve(results);
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"recognizeFileInMemory",
                "id":taskID,
                "instanceID":this._instanceID,
                body:{
                    config: config,
                    bytes: bytes
                }
            });
        });
    }

    private async _recognize_Blob(blob:Blob, config?: any): Promise<DLRResult[]> {
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Blob(blob: Blob)');
        
        let useObjurlToDrawBlobToImg = function(blob: Blob): Promise<HTMLImageElement>{
            return new Promise((resolve, reject)=>{
                let objUrl = URL.createObjectURL(blob);
                let image = new Image();
                (image as any).dlrObjUrl = objUrl;
                image.src = objUrl;
                image.onload = () => {
                    URL.revokeObjectURL(objUrl);
                    resolve(image);
                };
                image.onerror = ev => {
                    reject(new Error("Can't convert blob to image : "  + (ev instanceof Event ? ev.type : ev)));
                }
            })
        }

        let imageBitmap: ImageBitmap = null;
        let img: HTMLImageElement = null;
        if(typeof createImageBitmap != "undefined"){
            try{
                imageBitmap = await createImageBitmap(blob);
            }catch(ex){
                // createImageBitmap maybe fail in a lot of sense
                // although objurl can pass
            }
        }
        if(!imageBitmap){
            img = await useObjurlToDrawBlobToImg(blob);
        }

        let results = await this._recognize_Image(imageBitmap || img, config);
        if(imageBitmap){ imageBitmap.close(); } // release memory
        return results;
    }
    
    // ArrayBuffer
    /**
     * 
     * @param arrayBuffer 
     * @param config 
     * @ignore
     */
    private async _recognize_ArrayBuffer(arrayBuffer:ArrayBuffer,config?:any):Promise<DLRResult[]>{
        return await this._recognize_Blob(new Blob([arrayBuffer]),config);
    }
    
    // Uint8Array
    /**
     * 
     * @param uint8Array 
     * @param config 
     * @ignore
     */
    private async _recognize_Uint8Array(uint8Array:Uint8Array|Uint8ClampedArray,config?:any):Promise<DLRResult[]>{
        return await this._recognize_Blob(new Blob([uint8Array]),config);
    }
    
    /**
     * 
     * @param image 
     * @param config
     * @ignore 
     */
    private async _recognize_Image(image: HTMLImageElement|ImageBitmap, config?: any): Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Image(image: HTMLImageElement|ImageBitmap)');
        
        config = config || {};

        let imgW = image instanceof HTMLImageElement ? image.naturalWidth : image.width;
        let imgH = image instanceof HTMLImageElement ? image.naturalHeight : image.height;
        let maxNaturalWH = Math.max(imgW, imgH);
        let acceptW: number, acceptH: number;
        if(maxNaturalWH > this._maxCvsSideLength){
            let rate:number = this._maxCvsSideLength / maxNaturalWH;
            acceptW = Math.round(imgW * rate);
            acceptH = Math.round(imgH * rate);
        }else{
            acceptW = imgW;
            acceptH = imgH;
        }
        
        if(!this.canvas) {
            this.canvas = document.createElement('canvas');
        }
        const cvs = this.canvas;
        if(cvs.width !== acceptW || cvs.height !== acceptH){
            cvs.width = acceptW;
            cvs.height = acceptH;
        }
        if(!(cvs as any).ctx2d) {
            (cvs as any).ctx2d = cvs.getContext('2d', {willReadFrequently: true});
        }
        const ctx = (cvs as any).ctx2d;

        ctx.drawImage(image,0,0,imgW,imgH,0,0,acceptW,acceptH);

        if((image as any).dlrObjUrl){
            URL.revokeObjectURL((image as any).dlrObjUrl); // relese memory
        }

        let results = await this._recognize_Canvas(cvs, config);
        return results;
    }
    
    private async _recognize_Canvas(canvas:HTMLCanvasElement, config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Canvas(canvas:HTMLCanvasElement)');

        if((canvas as any).crossOrigin && "anonymous" != (canvas as any).crossOrigin){ // canvas has crossOrigin to detect if cors, is native api
            throw "cors";
        }

        if(canvas.width === 0 || canvas.height === 0) {
            throw Error(`The width or height of the 'canvas' is 0.`);
        }

        if(this.ifSaveOriginalImageInACanvas) {
            this.oriCanvas = canvas;
            this.oriCanvasData = null;
        }

        let ctx = ((canvas as any).ctx2d as CanvasRenderingContext2D) || canvas.getContext("2d");

        let data = ctx.getImageData(0,0,canvas.width,canvas.height).data;
        return await this._recognizeBuffer_Uint8Array(data, canvas.width, canvas.height, canvas.width * 4,EnumDLRImagePixelFormat.IPF_ABGR_8888, config);
    }
    
    /**
     * recognize video is not multi call safe in an instance, we reuse many thing for speed, so make sure wait util one finish then call next
     * @param video
     * @param config
     * @ignore
     */
    async _recognize_Video(video:HTMLVideoElement,config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Video(video)');

        if(!(video instanceof HTMLVideoElement)){
            throw TypeError("'_recognize_Video(video [, config] )': Type of 'video' should be 'HTMLVideoElement'.");
        }
        if(video.crossOrigin && "anonymous" != video.crossOrigin){
            throw "cors";
        }

        config = config || {};
        
        let imgW = video.videoWidth;
        let imgH = video.videoHeight;
        let maxNaturalWH = Math.max(imgW, imgH);
        let acceptW: number, acceptH: number;
        if(maxNaturalWH > this._maxCvsSideLength){
            let rate:number = this._maxCvsSideLength / maxNaturalWH;
            acceptW = Math.round(imgW * rate);
            acceptH = Math.round(imgH * rate);
        }else{
            acceptW = imgW;
            acceptH = imgH;
        }
        
        // recognize with region, use drawImage to draw
        if(!this.canvas) {
            this.canvas = document.createElement('canvas');
        }
        const cvs = this.canvas;
        if(cvs.width !== acceptW || cvs.height !== acceptH){
            cvs.width = acceptW;
            cvs.height = acceptH;
        }
        if(!(cvs as any).ctx2d) {
            (cvs as any).ctx2d = cvs.getContext('2d');
        }
        const ctx = (cvs as any).ctx2d;

        ctx.drawImage(video,0,0,imgW,imgH,0,0,acceptW,acceptH);

        let results = await this._recognize_Canvas(cvs, config);
        return results;
    }

    /**@ignore */
    async _recognize_DCEFrame(dceFrame:DCEFrame,config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_DCEFrame(dceFrame)');
        
        if(!isDCEFrame(dceFrame)) return [];

        let results:DLRResult[] = [];
        if(this.ifSaveOriginalImageInACanvas){
            this.oriCanvas = null;
            this.oriCanvasData = {
                width: dceFrame.width,
                height: dceFrame.height,
                colorMode: dceFrame.colorMode,
                data: new Uint8Array(dceFrame.data),
                toCanvas: dceFrame.toCanvas
            };
        }
        const {width, height, colorMode, timeStamp} = dceFrame;
        let data;
        if(config && config.bCopyData) {
            data = new Uint8Array(dceFrame.data);
        } else {
            data = dceFrame.data;
        }

        let newConfig:any = null;
        if(config) {
            newConfig = JSON.parse(JSON.stringify(config));
            newConfig.timeStamp = timeStamp;
        } else {
            newConfig = {
                timeStamp
            };
        }

        if(colorMode === 'grey') {
            results = await this._recognizeBuffer_Uint8Array(data, width, height, width, EnumDLRImagePixelFormat.IPF_GRAYSCALED, newConfig);
        } else if(colorMode === 'rgba'){
            results = await this._recognizeBuffer_Uint8Array(data, width, height, width * 4,EnumDLRImagePixelFormat.IPF_ABGR_8888, newConfig);
        } else if(colorMode === 'bgra'){
            results = await this._recognizeBuffer_Uint8Array(data, width, height, width * 4,EnumDLRImagePixelFormat.IPF_ARGB_8888, newConfig);
        } else {
            throw new Error(`Color mode '${colorMode}' is not supported to recognize.`)
        }
        return results;
    }
    
    /**@ignore */
    async _recognize_DSImage(dsImage:DSImage,config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_DSImage(dsImage)');
        
        if(!isDSImage(dsImage)) return null;

        if(this.ifSaveOriginalImageInACanvas){
            this.oriCanvas = null;
            this.oriCanvasData = {
                width: dsImage.width,
                height: dsImage.height,
                pixelFormat: dsImage.pixelFormat.toLowerCase(),
                data: new Uint8Array(dsImage.data),
                toCanvas: function() {
                    const cvs = document.createElement("canvas");
                    cvs.width = this.width;
                    cvs.height = this.height;
                    let pixels;
                    switch (this.pixelFormat) {
                        case "grey":
                            pixels = new Uint8ClampedArray(this.width*this.height*4);
                            for(let i = 0; i < pixels.length; i+=4) {
                                pixels[i] = this.data[i/4];
                                pixels[i+1] = this.data[i/4];
                                pixels[i+2] = this.data[i/4];
                                pixels[i+3] = 255;
                            }
                            break;
                        case "rgb":
                            pixels = new Uint8ClampedArray(this.width*this.height*4);
                            for(let i = 0; i < pixels.length; i+=4) {
                                pixels[i] = this.data[i];
                                pixels[i+1] = this.data[i+1];
                                pixels[i+2] = this.data[i+2];
                                pixels[i+3] = 255;
                            }
                            break;
                        case "bgr":
                            pixels = new Uint8ClampedArray(this.width*this.height*4);
                            for(let i = 0; i < pixels.length; i+=4) {
                                pixels[i] = this.data[i];
                                pixels[i+1] = this.data[i+1];
                                pixels[i+2] = this.data[i+2];
                                pixels[i+3] = 255;
                            }
                            break;
                        case "rgba":
                            pixels = new Uint8ClampedArray(this.data);
                            break;
                        case "bgra":
                            pixels = new Uint8ClampedArray(this.data);
                            break;
                        default:
                            throw new Error(`The content of 2D Canvas is currently limited to the sRGB color space.`);
                    }

                    const imageData = new ImageData(pixels, this.width, this.height);
                    cvs.getContext("2d").putImageData(imageData, 0, 0);
                    return cvs;
                }
            };
        }
        const {width, height} = dsImage;
        let pixelFormat = dsImage.pixelFormat.toLowerCase();
        let data;
        if(config && config.bCopyData) {
            data = new Uint8Array(dsImage.data);
        } else {
            data = dsImage.data;
        }
        let stride:number;
        let dlrImagePixelFormat:EnumDLRImagePixelFormat;
        switch (pixelFormat) {
            case "grey":
                dlrImagePixelFormat = EnumDLRImagePixelFormat.IPF_GRAYSCALED;
                stride = width;
                break;
            case "rgb":
                dlrImagePixelFormat = EnumDLRImagePixelFormat.IPF_BGR_888;
                stride = width * 3;
                break;
            case "bgr":
                dlrImagePixelFormat = EnumDLRImagePixelFormat.IPF_RGB_888;
                stride = width * 3;
                break;
            case "rgba":
                dlrImagePixelFormat = EnumDLRImagePixelFormat.IPF_ABGR_8888;
                stride = width * 4;
                break;
            case "bgra":
                dlrImagePixelFormat = EnumDLRImagePixelFormat.IPF_ARGB_8888;
                stride = width * 4;
                break;
            default:
                throw new Error(`The pixel format is not supported to recognize.`);
        }

        const results = await this._recognizeBuffer_Uint8Array(data, width, height, stride, dlrImagePixelFormat, config);
        return results;
    }

    private async _recognize_Base64(base64Str:string,config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Base64(base64Str)');

        if(!(typeof base64Str == 'string' || typeof base64Str == 'object' )){
            return Promise.reject("'_recognize_Base64(base64Str, config)': Type of 'base64Str' should be 'string'.");
        }
        if(base64Str.substring(0, 11) == "data:image/"){
            base64Str = base64Str.substring(base64Str.indexOf(',')+1);
        }
        if(!bNode){
            let binaryStr = atob(base64Str);
            let n = binaryStr.length;
            let u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = binaryStr.charCodeAt(n);
            }
            return await this._recognize_Blob(new Blob([u8arr]),config);
        }else{
            let buffer = Buffer.from(base64Str, "base64");
            return await this._recognizeFileInMemory_Uint8Array(new Uint8Array(buffer),config);
        }
    }
    
    private async _recognize_Url(url:string, config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_Url(url)');
        if(!(typeof url == 'string' || typeof url == 'object')){
            throw TypeError("'_recognize_Url(url, config)': Type of 'url' should be 'string'.");
        };

        if(!bNode){
            const blob = (await new Promise((resolve, reject)=>{
                const http = new XMLHttpRequest();
                http.open("GET", url, true);
                http.responseType = "blob";
                http.send();
                http.onloadend = async() => {
                    resolve(http.response);
                };
                http.onerror = () => {
                    reject(new Error("Network Error: " + http.statusText));
                };
            }) as Blob);
            return await this._recognize_Blob(blob, config);
        }else{
            const bytes = (await new Promise((resolve, reject)=>{
                const http = url.startsWith('https') ? require('https') : require('http');
                http.get(url, (res: any) => {
                    if(200 == res.statusCode){
                        let data: any = [];
                        res.on('data', (chunk: any) => {
                            data.push(chunk);
                        }).on('end', () => {
                            //at this point data is an array of Buffers
                            //so Buffer.concat() can make us a new Buffer
                            //of all of them together
                            resolve(new Uint8Array(Buffer.concat(data)));
                        });
                    }else{
                        reject('http get fail, statusCode: '+res.statusCode);
                    }
                });
            }) as Uint8Array);
            return await this._recognizeFileInMemory_Uint8Array(bytes,config);
        }

    }

    private async _recognize_FilePath(path:any, config?:any):Promise<DLRResult[]>{
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('_recognize_FilePath(path)');
        if(!bNode){
            throw Error("'_recognize_FilePath(path, config)': The method is only supported in node environment.");
        }
        if(!(typeof path == 'string' || typeof path == 'object')){
            throw TypeError("'_recognize_FilePath(path, config)': Type of 'path' should be 'string'.");
        }

        const fs = require('fs');
        let data = (await new Promise((resolve, reject)=>{
            fs.readFile(path, (err: any, data: any) => {
                if(err){
                    reject(err);
                }else{
                    resolve(new Uint8Array(data));
                }
            });
        }) as Uint8Array);

        return await this._recognizeFileInMemory_Uint8Array(data,config);
    }

    /**
     * Resets all parameters to default values.
     * ```js
     * await recognizer.resetRuntimeSettings();
     * ```
     * @category Runtime Settings
     */
    async resetRuntimeSettings(): Promise<void>{
        this.region = null;
        this._updateMinLtrSel(0);
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"resetRuntimeSettings",
                "id":taskID,
                "instanceID":this._instanceID
            });
        });
    }

    /**
     * Update runtime settings with a given json, or a string of 
     * `numberLetter`, `number`, `letter`, `numberUppercase`, `cppdefault`, `VIN`, `VIN_NA`, `passportMRZ`, `visaMRZ`, `MRZ`
     * `video-numberLetter`, `video-number`, `video-letter`, `video-numberUppercase`, `video-cppdefault`, `video-VIN`, `video-VIN_NA`, `video-passportMRZ`, `video-visaMRZ`, `video-MRZ`
     * to use preset settings for LabelRecognizer.
     * The default settings for LabelRecognizer is `cppdefault`.
     * ```js
     * let settings = JSON.parse(await recognizer.outputRuntimeSettingsToString());
     * let region = settings.ReferenceRegionArray[0].Localization;
     * region.FirstPoint = [0,40];
     * region.SecondPoint = [100,40];
     * region.ThirdPoint = [100,60];
     * region.FourthPoint = [0,60];
     * await recognizer.updateRuntimeSettingsFromString(JSON.stringify(settings));
     * ```
     * ```js
     * await scanner.updateRuntimeSettingsFromString('numberLetter');
     * ```
     * @category Runtime Settings
     */
    async updateRuntimeSettingsFromString(settings: any, bKeepTemplate: Boolean = false): Promise<void>{
        let minLetter = 0;
        if(typeof settings == 'string'){
            settings = settings.trim();
            if(settings.startsWith('{')){
                settings = JSON.parse(settings);
                if(!bKeepTemplate) this.currentSettingsTemplate = null;
            }else{
                if(settings.length > 50){
                    throw new Error("Error: preset longer than 50 letters.");
                }
                const presetDefines = settings.toLowerCase().split('-');
                if(presetDefines.length > 2){
                    throw new Error(`Error: '${settings}' is not supported.`);
                }
                if(presetDefines.includes("numberletter")){
                    minLetter = 3;
                    this.currentSettingsTemplate = "numberLetter";
                }else if(presetDefines.includes("numberuppercase")){
                    minLetter = 3;
                    this.currentSettingsTemplate = "numberUppercase";
                }else if(presetDefines.includes("number")){
                    minLetter = 3;
                    this.currentSettingsTemplate = "number";
                }else if(presetDefines.includes("letter")){
                    minLetter = 3;
                    this.currentSettingsTemplate = "letter";
                }else if(presetDefines.includes("passportmrz")){
                    minLetter = 44;
                    this.currentSettingsTemplate = "passportMRZ";
                }else if(presetDefines.includes("visamrz")){
                    minLetter = 36;
                    this.currentSettingsTemplate = "visaMRZ";
                } else if(presetDefines.includes("idcardmrz")) {
                    minLetter = 30;
                    this.currentSettingsTemplate = "idcardMRZ"
                } else if(presetDefines.includes("mrz")){
                    minLetter = 30;
                    this.currentSettingsTemplate = "MRZ";
                }else if(presetDefines.includes("vin_na")){
                    minLetter = 17;
                    this.currentSettingsTemplate = "VIN_NA";
                }else if(presetDefines.includes("vin")){
                    minLetter = 17;
                    this.currentSettingsTemplate = "VIN";
                }else if(presetDefines.includes("cppdefault")){
                    this.currentSettingsTemplate = "cppdefault";
                    // do nothing
                }else{
                    throw new Error(`Error: '${settings}' is not supported.`);
                }
                if(presetDefines.includes("video")){
                    if(!this.dce) throw new Error(`'CameraEnhancer' instance is required through 'setImageSource()' when using the 'video' prefix template.`);
                    this.region = null;
                    this.dce.setScanRegion(this.presetVideoTemplateRegion);
                } else {
                    this.region = null;
                    if(this.dce && isPresetRegion(this.dce.getScanRegion())) {
                        this.dce.setScanRegion(null);
                    }
                }
            }
        } else if(typeof settings == 'object') {
            if(!bKeepTemplate) this.currentSettingsTemplate = null;
        } else{
            throw TypeError("'updateRuntimeSettingsFromString(settings)': Type of 'settings' should be 'string' or 'PlainObject'.");
        }

        if(typeof settings == 'object') {
            const obj = settings.ReferenceRegionArray[0].Localization;
            const region = obj.FirstPoint ? {
                localizationSourceType: EnumDLRLocalizationSourceType[obj.SourceType as (keyof typeof EnumDLRLocalizationSourceType)],
                location: {
                    points: [{x: obj.FirstPoint[0],y: obj.FirstPoint[1]},{x: obj.SecondPoint[0],y: obj.SecondPoint[1]},{x: obj.ThirdPoint[0],y: obj.ThirdPoint[1]},{x: obj.FourthPoint[0],y: obj.FourthPoint[1]}]
                },
                regionMeasuredByPercentage: obj.MeasuredByPercentage,
            } as DLRReferenceRegion : null; // todo: it's region from barcode, need to do more
            if(region && isRegionNormalPreset(region)){ // todo: it's region from barcode, need to do more
                this.region = null;
            }else{
                this.region = region;
            }
            const lslr = settings.LabelRecognizerParameterArray[0].LineStringLengthRange;
            minLetter = lslr ? lslr[0] : 0;
        }
        
        this._updateMinLtrSel(minLetter);

        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    try{
                        this._handleRetJsonString(body.updateReturn);
                    }catch(ex){
                        reject(ex);
                    }
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"updateRuntimeSettingsFromString",
                "id":taskID,
                "instanceID":this._instanceID,
                body:{
                    settings
                }
            });
        });
    }
    /**
     * Gets current settings and save it into a json.
     * ```js
     * let settings = await recognizer.getRuntimeSettings();
     * settings.referenceRegion.location.points = [{x: 0,y: 40},{x: 100,y: 40},{x: 100,y: 60},{x: 0,y: 60}];
     * await recognizer.updateRuntimeSettings(settings);
     * ```
     * @see [updateRuntimeSettingsFromString]()
     * @category Runtime Settings
     */
    async outputRuntimeSettingsToString(): Promise<string>{
        return await new Promise((resolve,reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body: any) =>{
                if(body.success){
                    // let runtimeSettings = JSON.parse(body.results);
                    // return resolve(runtimeSettings);
                    return resolve(body.results);
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type: "outputSettingsToString",
                "id":taskID,
                "instanceID": this._instanceID,
            });
        });
    }

    /**
     * @category Runtime Settings
     */
    async updateReferenceRegionFromBarcodeResults(dbrTextResults:any): Promise<void>{
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"updateReferenceRegionFromBarcodeResults",
                "id":taskID,
                "instanceID":this._instanceID,
                body:{
                    dbrTextResults:dbrTextResults
                }
            });
        });
    }

    /**
     * Initialize runtime settings with the settings in given JSON string.
     * ```js
     * await recognizer.appendCaffeModelBuffer("Number","@engineResourcePath");
     * ```
     * @ignore
     * @category Runtime Settings
     */
    static async appendCaffeModelBuffer(name:string, folderUrl:string): Promise<void>{
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    try{
                        return resolve();
                    }catch(ex){
                        reject(ex);
                    }
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"appendCaffeModelBuffer",
                "id":taskID,
                body:{
                    name,
                    folderUrl
                }
            });
        });
    }

    /**
     * Resets all parameters to default values.
     * ```js
     * await recognizer.appendCaffeModelBuffer("Number","@engineResourcePath");
     * await recognizer.eraseCaffeModelByName("Number");
     * ```
     * @ignore
     * @category Runtime Settings
     */
    static async eraseCaffeModelByName(name: string): Promise<void>{
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"eraseCaffeModelByName",
                "id":taskID,
                body:{
                    name
                }
            });
        });
    }

    /**
     * Resets all parameters to default values.
     * ```js
     * await recognizer.appendCaffeModelBuffer("Number","@engineResourcePath");
     * await recognizer.eraseAllCaffeModels();
     * ```
     * @ignore
     * @category Runtime Settings
     */
    static async eraseAllCaffeModels(): Promise<void>{
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({type:"eraseAllCaffeModels","id":taskID});
        });
    }

    /** @ignore */
    static LabelRecognizerException(ag0:any, ag1:any):LabelRecognizerException{
        let ex:Error;
        
        let code = EnumDLRErrorCode.UNKNOWN;
        if(typeof ag0 == "number"){
            code = ag0;
            ex = new Error(ag1);
        }else{
            ex = new Error(ag0);
        }
        (ex as LabelRecognizerException).code = code;
        return ex;
    }


    private _handleRetJsonString(objRet:any):any{
        let e = EnumDLRErrorCode;
        
        if(objRet.results){
            // it's a recognize task
            const drawRegionsultRecords = this.drawRegionsultRecords;
            const mapThisFrameTxts:any = {};
            for(let i=0; i<objRet.results.length; i++){
                let aResult = objRet.results[i];
                if (aResult.exception != null) {
                    if(!this._setWarnnedEx.has(aResult.exception)){
                        this._setWarnnedEx.add(aResult.exception);
                        console.warn(aResult.exception);
                    }
                    let exceptionObj: any = {};
                    let excp = aResult.exception.split(';');
                    
                    excp.forEach((prop: any) => {
                        let pos = prop.indexOf(":");
                        exceptionObj[prop.substring(0, pos)] = prop.substring(pos+1);
                    })
                    aResult.exception = exceptionObj;
                }
                for(let lineResult of aResult.lineResults){
                    const txt = lineResult.text;
                    mapThisFrameTxts[txt] = 1;
                    if(lineResult.bUnduplicated){
                        const arr = drawRegionsultRecords[txt] = drawRegionsultRecords[txt] || [];
                        arr.push(lineResult);
                    }else{
                        // todo: how about find two same line in one frame
                        if(drawRegionsultRecords[txt]){
                            drawRegionsultRecords[txt] = [lineResult];
                        }
                    }
                }
            }
            if(objRet.records){
                const records = this.recognizeRecords = objRet.records;
                for(let txt in drawRegionsultRecords){
                    if(!records[txt]){ delete drawRegionsultRecords[txt]; }
                }
                for(let txt in drawRegionsultRecords){
                    if(!mapThisFrameTxts[txt]){
                        drawRegionsultRecords[txt] = [];
                    }
                }
            }else{
                this.recognizeRecords = {};
                this.drawRegionsultRecords = {};
            }
            this._lastErrorCode = objRet.exception;
            this._lastErrorString = objRet.description;
            if(objRet.exception && !this._setWarnnedEx.has(objRet.description)){
                this._setWarnnedEx.add(objRet.description);
                if(objRet.exception == EnumDLRErrorCode.LICENSE_INVALID || objRet.exception == EnumDLRErrorCode.LICENSE_EXPIRED) {
                    console.error(objRet.description);
                } else {
                    console.warn(objRet.description);
                }

            }
            return objRet.results;
        }else{
            // other method task
            if(objRet.exception == e.OK){
                return objRet.data;
            }else{
                throw LabelRecognizer.LabelRecognizerException(objRet.exception, objRet.description);
            }
        }
    }

    // ===================================== scanner related =========================================================

    private async clearMapDecodeRecord():Promise<void>{
        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({type:"clearMapDecodeRecord","id":taskID,"instanceID":this._instanceID});
        })
    }

    /** @ignore */
    _onMinLetterSelChange = async(ev:Event)=>{
        let value = (ev.target as HTMLSelectElement).value;
        if('got' === value){return;}
        value = JSON.parse(value);
        let settings = JSON.parse(await this.outputRuntimeSettingsToString());
        settings.LabelRecognizerParameterArray[0].LineStringLengthRange = [value, 999];
        settings.TextAreaArray[0].LineStringLengthRange = [value, 999];
        await this.updateRuntimeSettingsFromString(settings);
    }

    /** @ignore */
    _bindUI(): void{
        if(!this.dce) return;

        this._selMinLtr = this.dce._selMinLtr;
        this._optGotMinLtr = this.dce._optGotMinLtr;
        //add EventListner
        if(!this.dce.singleFrameMode){
            if(this._selMinLtr){
                this._selMinLtr.addEventListener('change', this._onMinLetterSelChange);
            }
        }
        this._updateMinLtrSel(this._minLetter);
    }

    /** @ignore */
    _unbindUI():void{
        if(this._selMinLtr){
            this._selMinLtr.removeEventListener('change', this._onMinLetterSelChange);
        }
        this._selMinLtr = null;
        this._optGotMinLtr = null;
    }

    /**
     * The event that is triggered once a single frame has been scanned.
     * The results object contains all the results that the recognizer was able to recognize.
     * ```js
     * scanner.onImageRead = results => {
     * for(let result of results){
     *     for(let lineResult of result.lineResults){
     *         console.log(lineResult.text);
     *     }
     * }
     * };
     * ```
     */
    onImageRead?: (results: DLRResult[]) => void;

    /**
     * This event is triggered when a not duplicated new character line is found.
     * txt holds the text result. result contains the actual line result, including the text result. 
     * Old character line will remember for duplicateForgetTime.
     * ```js
     * scanner.onUniqueRead = (txt, result) => {
     *     alert(txt);
     *     console.log(result);
     * };
     * ```
     */
    onUniqueRead?: (txt: string, result: DLRLineResult) => void;

    onMRZRead?: (txt: string, result: DLRLineResult[]) => void;

    onVINRead?: (txt: string, result: DLRLineResult) => void;

    /**
     * Get current scan settings of the LabelRecognizer object and saves it into a struct.
     * ```js
     * let scanSettings = await scanner.getScanSettings();
     * scanSettings.intervalTime = 50;
     * scanSettings.duplicateForgetTime = 1000;
     * await scanner.updateScanSettings(scanSettings);
     * ```
     */
    async getScanSettings(): Promise<ScanSettings>{
        return await new Promise((resolve,reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body: any) =>{
                if(body.success){
                    let settings = body.results;
                    settings.intervalTime = this.intervalTime;
                    settings.whenToPlaySoundforSuccessfulRead = this.whenToPlaySoundforSuccessfulRead;
                    settings.soundOnSuccessfullRead = this.soundSource;
                    settings.whenToVibrateforSuccessfulRead = this.whenToVibrateforSuccessfulRead;
                    settings.vibrateDuration = this.vibrateDuration;
                    settings.captureAndRecognizeInParallel = this.captureAndRecognizeInParallel;
                    return resolve(settings);
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack += '\n' + body.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type: "getScanSettings",
                "id":taskID,
                "instanceID": this._instanceID,
            });
        });
    }

    /**
     * Update ScanSettings by specify parameter values.
     * ```js
     * let scanSettings = await scanner.getScanSettings();
     * scanSettings.intervalTime = 50;
     * scanSettings.duplicateForgetTime = 1000;
     * await scanner.updateScanSettings(scanSettings);
     * ```
     * @param settings 
     */
    async updateScanSettings(settings: ScanSettings):Promise<void>{
        if(!settings) return; 
        const scanSettings = JSON.parse(JSON.stringify(settings));
        if(scanSettings.hasOwnProperty("intervalTime")) {
            if(scanSettings.intervalTime < 0) {
                scanSettings.intervalTime = 0; 
            }
            this.intervalTime = scanSettings.intervalTime;
            delete scanSettings.intervalTime;
        }
        if(scanSettings.hasOwnProperty("whenToPlaySoundforSuccessfulRead")) {
            this.whenToPlaySoundforSuccessfulRead = scanSettings.whenToPlaySoundforSuccessfulRead;
            delete scanSettings.whenToPlaySoundforSuccessfulRead;
        }
        if(scanSettings.hasOwnProperty("soundOnSuccessfullRead")) {
            this.soundSource = scanSettings.soundOnSuccessfullRead;
            delete scanSettings.soundOnSuccessfullRead;
        }
        if(scanSettings.hasOwnProperty("whenToVibrateforSuccessfulRead")) {
            this.whenToVibrateforSuccessfulRead = scanSettings.whenToVibrateforSuccessfulRead;
            delete scanSettings.whenToVibrateforSuccessfulRead;
        }
        if(scanSettings.hasOwnProperty("vibrateDuration")) {
            this.vibrateDuration = scanSettings.vibrateDuration;
            delete scanSettings.vibrateDuration;
        }
        if(scanSettings.hasOwnProperty("captureAndRecognizeInParallel")) {
            this.captureAndRecognizeInParallel = scanSettings.captureAndRecognizeInParallel;
            delete scanSettings.captureAndRecognizeInParallel;
        }

        return await new Promise((resolve, reject) => {
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }else{
                    let ex = new Error(body.message);
                    ex.stack += '\n' + body.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({     
                type: "updateScanSettings",
                "id": taskID,
                "instanceID": this._instanceID,
                body:{
                    settings: settings
                }
            })
        })
    }

    /** @ignore */
    _cloneDecodeResults(results: any):any{
        if(results instanceof Array){
            let newResults:any[] = [];
            for(let result of results){
                newResults.push(this._cloneDecodeResults(result))
            }
            return newResults;
        }else{
            let result = results;
            let newResults = JSON.parse(JSON.stringify(result, (k, v)=>{
                if(k == 'oriVideoCanvas' || k == 'searchRegionCanvas'){
                    return undefined;
                }else{
                    return v;
                }
            }));
            return newResults;
        }
    }

    /** @ignore */    
    private async _loopReadVideo(): Promise<void>{
        if(this.bDestroyed){ 
            if(this.dce && this._dceControler) {
                this._dceControler.setDisiredAction(this, "stopFetchingLoop");
            }
            this._drawResults(null);
            return;
        }
        if(this.dce && !this.dce.isOpen()){
            this._drawResults(null);
            await this.clearMapDecodeRecord();
            return;
        }
        if(!this.dce && !this.imgSource || this._bPauseScan){
            if(LabelRecognizer._onLog)LabelRecognizer._onLog('Scan is paused, or imageSource is not set. Ask in 1s.');
            // this._drawResults(null);
            await this.clearMapDecodeRecord();
            this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
            this._loopReadVideoTimeoutId = setTimeout(()=>{
                this._loopReadVideo();
            },this._intervalDetectVideoPause);
            return;        
        }

        if(LabelRecognizer._onLog)LabelRecognizer._onLog('======= once read =======');

        if(LabelRecognizer._onLog)this._timeStartRecognize = Date.now();// for debug

        let dceFrame:DCEFrame = null;
        let dsImage:DSImage = null;
        if(this.dce) {
            dceFrame = this._getVideoFrame();
            // if(!dceFrame) {
            //     this._drawResults(null);
            //     return;
            // }
        } else if(this.imgSource) {
            dsImage = await this.imgSource.getImage();
            if(!isDSImage(dsImage)) throw new Error(`Invalid DSImage.`);
        }

        if(!dceFrame && !dsImage) {
            if(LabelRecognizer._onLog)LabelRecognizer._onLog('Get invalid frame.');

            // this._drawResults(null);
            this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
            this._loopReadVideoTimeoutId = setTimeout(()=>{
                this._loopReadVideo();
            }, 0);
            return;
        }
        
        (async()=>{
            let results:DLRResult[] = [];
            
            if(dceFrame) {
                results = await this._recognize_DCEFrame(dceFrame, {bScanner:true, bCopyData:false});
                let locations = null;
                if(results && results.length) {
                    const {sx, sy, width, height, _sWidth, _sHeight} = dceFrame;
                    locations = results.map(result=>{
                        return {
                            lineResults: result.lineResults.map(lineResult=>{
                                return {
                                    location: JSON.parse(JSON.stringify(lineResult.location))
                                };
                            })
                        };
                    });
                    LabelRecognizer.recalculateResultLocation(locations, sx, sy, _sWidth, _sHeight, width, height);
                }
                this._drawResults(locations);
            } else if(dsImage) {
                results = await this._recognize_DSImage(dsImage, {bScanner:true, bCopyData:false});
            }
            return results;
        })().then((results:DLRResult[])=>{
            if(LabelRecognizer._onLog)LabelRecognizer._onLog(results);
            if(this.dce && this.captureAndRecognizeInParallel) {
                let decodeCostArr = this.array_decodeFrameTimeCost;
                let getFrameCostArr = this.array_getFrameTimeCost;
                // let currentDocodedFrameIndex = this._indexCurrentDecodingFrame;
                const recordDecodingTimeCost = ()=>{
                    while(decodeCostArr.length >= 5) {
                        decodeCostArr.shift();
                    }
                    decodeCostArr.push(this._lastInnerDecodeDuration);
                };
                const calculateInterval = ()=>{
                    let interval = 0;
                    if(!getFrameCostArr || !getFrameCostArr.length) {
                        interval = 0
                    } else {
                        let minDecodeCost = Math.min(...decodeCostArr);
                        let maxGetFrameCost = Math.max(...getFrameCostArr);
                        minDecodeCost && maxGetFrameCost && (interval = minDecodeCost - maxGetFrameCost);
                    }
                    return interval > 0 ? interval : 0;
                };
                recordDecodingTimeCost();
                this._intervalGetVideoFrame = calculateInterval() + + this.intervalTime;
            }

            if((this.dce && this.dce.isOpen() || this.imgSource) && !this._bPauseScan){
                // play sound
                if(this.bPlaySoundOnSuccessfulRead && results.length){
                    let needPlaySoundInThisFrame = false;
                    if(true === this.bPlaySoundOnSuccessfulRead || "frame" === this.bPlaySoundOnSuccessfulRead){
                        needPlaySoundInThisFrame = true;
                    }else if("unique" === this.bPlaySoundOnSuccessfulRead){
                        for(let result of results){
                            for(let lineResult of result.lineResults){
                                if((lineResult as any).bUnduplicated){
                                    needPlaySoundInThisFrame = true;
                                    break;
                                }
                            }
                        }
                    }
                    if(needPlaySoundInThisFrame){
                        this.beepSound.stop();
                        this.beepSound.play();
                    }
                }
                if(navigator.vibrate && this.bVibrateOnSuccessfulRead && results.length){
                    let needVibrateInThisFrame = false;
                    if(true === this.bVibrateOnSuccessfulRead || "frame" === this.bVibrateOnSuccessfulRead){
                        needVibrateInThisFrame = true;
                    }else if("unique" === this.bVibrateOnSuccessfulRead){
                        for(let result of results){
                            for(let lineResult of result.lineResults){
                                if((lineResult as any).bUnduplicated){
                                    needVibrateInThisFrame = true;
                                    break;
                                }
                            }
                        }
                    }
                    if(needVibrateInThisFrame){
                        try{
                            navigator.vibrate(this.vibrateDuration);
                        }catch(err){
                            console.warn("Vibration not allowed. User interaction required: "+(err.message||err));
                        }
                    }
                }
                //onImageRead
                if(this.onImageRead){
                    let clonedResults = this._cloneDecodeResults(results);
                    for(let result of clonedResults){
                        for(let lineResult of result.lineResults){
                            if((lineResult as any).bUnduplicated){
                                delete (result as any).bUnduplicated;
                            }
                        }
                    }
                    this.onImageRead(clonedResults);
                }
                //onUniqueRead
                if(this.onUniqueRead){
                    for(let dlrResult of results){
                        for(let lineResult of dlrResult.lineResults){
                            if((lineResult as any).bUnduplicated){
                                this.onUniqueRead(lineResult.text, this._cloneDecodeResults(lineResult));
                            }
                        }
                    }
                }
                //onMRZRead
                if(this.onMRZRead){
                    const mrzRelatedTemplateList = ["MRZ", "passportMRZ", "visaMRZ", "idcardMRZ"];
                    // When current template is related mrz, combine multi-row result text to single row result text
                    if(mrzRelatedTemplateList.includes(this.currentSettingsTemplate)) {
                        let res = this._cloneDecodeResults(results) 
                        this._filterVideoModeMrzResult(res);
                    }
                }
                //onVINRead
                if(this.onVINRead){  
                    const vinRelatedTemplateList = ["VIN", "VIN_NA"];
                    if(vinRelatedTemplateList.includes(this.currentSettingsTemplate)) {
                        let clonedResults = this._cloneDecodeResults(results);
                        if(clonedResults.length) {
                            let sameCount: number = 0, bNeedBreak: boolean = false;
                            this._vinResultArrayTimeoutId && clearTimeout(this._vinResultArrayTimeoutId);
                            let resultStr = "";
                            for(let dlrResult of clonedResults) {
                                for(let dlrLineResult of dlrResult.lineResults) {
                                    if(dlrLineResult.characterResults.length === 18) {
                                        let standardDis = dlrLineResult.characterResults[9].location.points[0].x - dlrLineResult.characterResults[8].location.points[1].x;
                                        if(standardDis<2) standardDis=2;
                                        let leftDis = dlrLineResult.characterResults[1].location.points[0].x - dlrLineResult.characterResults[0].location.points[1].x;
                                        let rightDis = dlrLineResult.characterResults[17].location.points[0].x - dlrLineResult.characterResults[16].location.points[1].x;
                                        let faultTol = standardDis === 2 ? 3 : standardDis;
                                        if(leftDis - standardDis >= faultTol && rightDis - standardDis < faultTol) {
                                            dlrLineResult.characterResults.shift();
                                        } else if(rightDis - standardDis >= faultTol && leftDis - standardDis < faultTol) {
                                            dlrLineResult.characterResults.pop();
                                        } else {
                                            const leftCon = dlrLineResult.characterResults[0].characterHConfidence;
                                            const rightCon = dlrLineResult.characterResults[17].characterHConfidence;
                                            leftCon > rightCon ? dlrLineResult.characterResults.pop() : dlrLineResult.characterResults.shift();
                                        }
                                    } else if(dlrLineResult.characterResults.length === 19) {
                                        let standardDis = dlrLineResult.characterResults[10].location.points[0].x - dlrLineResult.characterResults[9].location.points[1].x;
                                        if(standardDis<2) standardDis=2;
                                        let left12Dis = dlrLineResult.characterResults[1].location.points[0].x - dlrLineResult.characterResults[0].location.points[1].x;
                                        let left1718Dis = dlrLineResult.characterResults[18].location.points[0].x - dlrLineResult.characterResults[17].location.points[1].x;
                                        let leftDis = dlrLineResult.characterResults[2].location.points[0].x - dlrLineResult.characterResults[1].location.points[1].x;
                                        let rightDis = dlrLineResult.characterResults[17].location.points[0].x - dlrLineResult.characterResults[16].location.points[1].x;
                                        let faultTol = standardDis === 2 ? 3 : standardDis;
                                        let ifHasOneLeftFaultTol;
                                        let ifHasOneRightFaultTol;

                                        let standardCharWidth;
                                        if(dlrLineResult.characterResults[1].characterH === "1" || dlrLineResult.characterResults[2].characterH === "1" || dlrLineResult.characterResults[16].characterH === "1" || dlrLineResult.characterResults[17].characterH === "1") {
                                            for(let i=9;i<dlrLineResult.characterResults.length;i++) {
                                                if(dlrLineResult.characterResults[i].characterH !== "1") {
                                                    standardCharWidth = dlrLineResult.characterResults[i].location.points[1].x - dlrLineResult.characterResults[i].location.points[0].x;
                                                    break;
                                                }
                                            }
                                            if(dlrLineResult.characterResults[1].characterH === "1") {
                                                ifHasOneLeftFaultTol = 3 + (standardCharWidth - (dlrLineResult.characterResults[1].location.points[1].x - dlrLineResult.characterResults[1].location.points[0].x));
                                            }
                                            if(dlrLineResult.characterResults[2].characterH === "1") {
                                                ifHasOneLeftFaultTol = 3 + (standardCharWidth - (dlrLineResult.characterResults[2].location.points[1].x - dlrLineResult.characterResults[2].location.points[0].x));
                                            }
                                            if(dlrLineResult.characterResults[16].characterH === "1") {
                                                ifHasOneRightFaultTol = 3 + (standardCharWidth - (dlrLineResult.characterResults[16].location.points[1].x - dlrLineResult.characterResults[16].location.points[0].x));
                                            }
                                            if(dlrLineResult.characterResults[17].characterH === "1") {
                                                ifHasOneRightFaultTol = 3 + (standardCharWidth - (dlrLineResult.characterResults[17].location.points[1].x - dlrLineResult.characterResults[17].location.points[0].x));
                                            }
                                        }

                                        if(leftDis - standardDis >= (ifHasOneLeftFaultTol ? ifHasOneLeftFaultTol : faultTol) && rightDis - standardDis < (ifHasOneRightFaultTol ? ifHasOneRightFaultTol : faultTol)) {
                                            dlrLineResult.characterResults.splice(0,2);
                                        } else if(rightDis - standardDis >= (ifHasOneRightFaultTol ? ifHasOneRightFaultTol : faultTol) && leftDis - standardDis < (ifHasOneLeftFaultTol ? ifHasOneLeftFaultTol : faultTol)) {
                                            dlrLineResult.characterResults.splice(17,2);
                                        } else if(left12Dis > standardDis && left1718Dis > standardDis) {
                                            dlrLineResult.characterResults.pop();
                                            dlrLineResult.characterResults.shift();
                                        } else {
                                            let leftCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[1].characterHConfidence;
                                            let rightCon = dlrLineResult.characterResults[17].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                                            let leftRightCon = dlrLineResult.characterResults[0].characterHConfidence + dlrLineResult.characterResults[18].characterHConfidence;
                                            let minValue = Math.min(leftCon, rightCon, leftRightCon);
                                            if(minValue === leftCon) {
                                                dlrLineResult.characterResults.splice(0,2);
                                            } else if(minValue === rightCon) {
                                                dlrLineResult.characterResults.splice(17,2);
                                            } else if(minValue === leftRightCon) {
                                                dlrLineResult.characterResults.pop();
                                                dlrLineResult.characterResults.shift();
                                            }
                                        }
                                    }
                                    for(let oneChar of dlrLineResult.characterResults) {
                                        resultStr += oneChar.characterH;
                                    }
                                }
                            }
                            this._vinResultArray.length === 5 && this._vinResultArray.shift();
                            this._vinResultArray.push(resultStr);
                            if(this._vinResultArray.length >= 2) {
                                for(let i = 0; i < this._vinResultArray.length; i++) {
                                    for(let j = 0; j < this._vinResultArray.length; j++) {
                                        if(this._vinResultArray[i] === this._vinResultArray[j]) {
                                            sameCount++;
                                            if(sameCount === 2) {
                                                this.onVINRead(this._vinResultArray[i], results[0].lineResults[0]);
                                                bNeedBreak = true;
                                                break;
                                            }
                                        }
                                    }
                                    sameCount = 0;
                                    if(bNeedBreak) break;
                                }
                            }
                        } else {
                            this._vinResultArrayTimeoutId = setTimeout(()=>{this._vinResultArray.shift();},500);
                        }
                    }
                }
                /* {
                    const trustResults = [];
                    for(let txt in this.drawRegionsultRecords){
                        trustResults.push(...this.drawRegionsultRecords[txt]);
                    }
                    this._drawResults([{lineResults:trustResults} as DLRResult]);
                } */
            }

            this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
            if(this.intervalTime) {
                this._loopReadVideoTimeoutId = setTimeout(()=>{
                    this._loopReadVideo();
                },this.intervalTime);
            } else {
                this._loopReadVideo();
            }
        }).catch((ex:Error)=>{
            if(this.dce && this._dceControler) {
                this._dceControler.setDisiredAction(this, "stopFetchingLoop");
            }
            if(LabelRecognizer._onLog)LabelRecognizer._onLog(ex.message || ex);
            this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
            this._loopReadVideoTimeoutId = setTimeout(()=>{
                if(this.dce) {
                    this.dce.startFetchingLoop();
                    if(this._dceControler) {
                        this._dceControler.clearUserDisiredAction({user:this, actionName: "stopFetchingLoop"})
                    }
                }
                this._loopReadVideo();
            }, Math.max(this.intervalTime, 1000));
            if(ex.message == 'platform error'){
                //// sometimes the src is not available, give up and do deocde in next loop 
            }else{
                console.warn(ex.message);
            }
        })
    }

    private _filterVideoModeMrzResult(result: any) {
        for(let dlrResult of result){
            let mrzText = "";
            let response: any = [];
            if(dlrResult.lineResults.length >= 2) {
                if(dlrResult.lineResults[dlrResult.lineResults.length-1].text.length > 30 && dlrResult.lineResults.length >= 2) {
                    response.push(dlrResult.lineResults[dlrResult.lineResults.length-2]);
                    response.push(dlrResult.lineResults[dlrResult.lineResults.length-1]);
                } else if(dlrResult.lineResults[dlrResult.lineResults.length-1].text.length <= 30 && dlrResult.lineResults.length >= 3) {
                    response.push(dlrResult.lineResults[dlrResult.lineResults.length-3]);
                    response.push(dlrResult.lineResults[dlrResult.lineResults.length-2]);
                    response.push(dlrResult.lineResults[dlrResult.lineResults.length-1]);
                }
            }
            for(let lineResult of response){
                if(mrzText.length > 0) {
                    mrzText += "\n";
                }
                mrzText += lineResult.text;
            }
            if(mrzText.length > 0) {
                this._verifyCheckDigit(response);
                this.onMRZRead(mrzText, response);
            }
        }
    }

    /** 
     * start dce fetching frame loop, and get frame from frame queue
     * @ignore 
     */
     private _getVideoFrame():DCEFrame {
        if(!this.dce) return null;
        // this.dce.loopInterval = this._intervalGetVideoFrame;
        // let bStartFetchingLoop = this.dce.isFetchingLoopStarted();
        let dceFrame: DCEFrame;
        if(this.captureAndRecognizeInParallel) {
            if(LabelRecognizer._onLog)LabelRecognizer._onLog('Get frame in parallel.');
            
            if(this._dceControler) {
                this._dceControler.setDisiredValue(this, "loopInterval", this._intervalGetVideoFrame);
            }
            // if(!bStartFetchingLoop) {
            //     this.dce.startFetchingLoop();
            // }
            if(!this.dce.numberOfFramesInBuffer) {
                if(this._dceControler) {
                    this._dceControler.setDisiredValue(this, "loopInterval", 0);
                }
                // this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
                // this._loopReadVideoTimeoutId = setTimeout(()=>{
                //     console.log("dlr: time out. loop read video.");
                //     this._loopReadVideo();
                // }, 0)
                return null;
            }
            dceFrame = this.dce.getFrameFromBuffer();
            // if the newest frame is 200ms ago, give it up.
            // if(!imgData || Date.now() - (imgData as any).timeStamp > 200) {
            //     this.dce.loopInterval = 0;
            //     return null;
            // }
            // this._indexCurrentDecodingFrame = this.dce.regionIndex;
            const recordFetchingTimeCost = (dceFrame:DCEFrame)=>{
                if(!dceFrame) return;
                let getFrameTimeCost = dceFrame.timeSpent;
                let arr = this.array_getFrameTimeCost;
                while(arr.length >= 5) {
                    arr.shift();
                }
                arr.push(getFrameTimeCost);
            }
            recordFetchingTimeCost(dceFrame);
        } else {
            if(LabelRecognizer._onLog)LabelRecognizer._onLog('Get frame in serial.');

            if(this._dceControler) {
                this._dceControler.setDisiredAction(this, "stopFetchingLoop");
            }
            dceFrame = this.dce.getFrame();
        }
        // console.log("dlr: record fetching time cost.");
        return dceFrame;
    }

    _drawResults(results: any) { 
        if(!this.dce || this._bPauseScan || !this._drawingItemNamespace || !this._drawingItemNamespace.DT_Polygon) return;
        if(!this._dlrDrawingLayer) {
            if(!this.dce.isOpen()) return;
            this._dlrDrawingLayer = this.dce.getDrawingLayer(2);
        }
        const layer = this._dlrDrawingLayer;

        if(!results) results = [];

        let polygons = this._arrPolygons;
        let index = 0;
        for(let dlrResult of results){
            for(let lineResult of dlrResult.lineResults){
                let p = lineResult.location.points;
                let polygon:any;
                if(!polygons[index]) {
                    polygon = new this._drawingItemNamespace.DT_Polygon([
                        {x: p[0].x, y: p[0].y},
                        {x: p[1].x, y: p[1].y},
                        {x: p[2].x, y: p[2].y},
                        {x: p[3].x, y: p[3].y},
                    ]);
                    layer.addDrawingItem(polygon);
                    polygons[index] = polygon;
                } else {
                    polygon = polygons[index];
                    if(!layer.hasDrawingItem(polygon)) {
                        layer.addDrawingItem(polygon);
                    }
                    polygon.set("vertices", [
                        {x: p[0].x, y: p[0].y},
                        {x: p[1].x, y: p[1].y},
                        {x: p[2].x, y: p[2].y},
                        {x: p[3].x, y: p[3].y},
                    ]);
                }
                index++;
            }
        }

        for(let i = index; i < polygons.length; i++) {
            layer.removeDrawingItem(polygons[i]);
        }
        layer.renderAll();
    }

    /**
     * check if the vin code is valid 
     * @ignore 
     */
    private _checkValidVIN(code: string):boolean {
        if(!code || code.length != 17) {
            return false;
        }
        const calculateVIN_NACheckDigit = (code: string)=>{
            const transliterationKey = new Map([
                ["A", 1],
                ["B", 2],
                ["C", 3],
                ["D", 4],
                ["E", 5],
                ["F", 6],
                ["G", 7],
                ["H", 8],
                ["J", 1],
                ["K", 2],
                ["L", 3],
                ["M", 4],
                ["N", 5],
                ["P", 7],
                ["R", 9],
                ["S", 2],
                ["T", 3],
                ["U", 4],
                ["V", 5],
                ["W", 6],
                ["X", 7],
                ["Y", 8],
                ["Z", 9],
                ["1", 1],
                ["2", 2],
                ["3", 3],
                ["4", 4],
                ["5", 5],
                ["6", 6],
                ["7", 7],
                ["8", 8],
                ["9", 9],
            ]);
            const weightFactorTable = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2];
            let sum = 0;
            for(let i = 0; i < code.length; i++) {
                let value = transliterationKey.get(code[i]);
                if(value) {
                    sum += value*weightFactorTable[i];
                }
            }
            return sum%11;
        };
        const checkDigit = calculateVIN_NACheckDigit(code);
        return checkDigit.toString() === code[8];
    }
    
    /**
     * check if the second row of passport mrz code is valid.
     * check digit only exits in second row in passport mrz.
     * @ignore 
     */
    private _checkValidMRP(code: string):boolean {
        if(!code || code.length != 44) {
            return false;
        }
        const calculateMRPCheckDigit = (code: string, startPosition: number, endPosition: number)=>{
            const transliterationKey = new Map([
                ["<", 0],
                ["0", 0],
                ["1", 1],
                ["2", 2],
                ["3", 3],
                ["4", 4],
                ["5", 5],
                ["6", 6],
                ["7", 7],
                ["8", 8],
                ["9", 9],
                ["A", 10],
                ["B", 11],
                ["C", 12],
                ["D", 13],
                ["E", 14],
                ["F", 15],
                ["G", 16],
                ["H", 17],
                ["I", 18],
                ["J", 19],
                ["K", 20],
                ["L", 21],
                ["M", 22],
                ["N", 23],
                ["O", 24],
                ["P", 25],
                ["Q", 26],
                ["R", 27],
                ["S", 28],
                ["T", 29],
                ["U", 30],
                ["V", 31],
                ["W", 32],
                ["X", 33],
                ["Y", 34],
                ["Z", 35]
            ]);
            const weightFactorTable = [7, 3, 1];
            let sum = 0;
            for(let i = startPosition, j = 0; i <= endPosition; i++) {
                let value = transliterationKey.get(code[i]);
                if(value) {
                    sum += value*weightFactorTable[j%3];
                }
                j++;
            }
            return sum%10;
        };
        const temp = code.slice(0, 10)+code.slice(13, 20)+code.slice(21, 43);
        const checkDigit_9 = calculateMRPCheckDigit(code, 0, 8).toString();
        const checkDigit_19 = calculateMRPCheckDigit(code, 13, 18).toString();
        const checkDigit_27 = calculateMRPCheckDigit(code, 21, 26).toString();
        const checkDigit_42 = calculateMRPCheckDigit(code, 28, 41).toString();
        const checkDigit_43 = calculateMRPCheckDigit(temp, 0, temp.length).toString();
        
        return checkDigit_9 === code[9] && checkDigit_19 === code[19] && checkDigit_27 === code[27] && checkDigit_42 === code[42] && checkDigit_43 === code[43];
    }
    
    /**
     * check if the second row of visa mrz code is valid.
     * check digit only exits in second row in visa mrz.
     * @ignore 
     */
    private _checkValidMRV(code: string):boolean {
        if(!code || (code.length != 44 && code.length != 36)) {
            return false;
        }
        const calculateMRPCheckDigit = (code: string, startPosition: number, endPosition: number)=>{
            const transliterationKey = new Map([
                ["<", 0],
                ["0", 0],
                ["1", 1],
                ["2", 2],
                ["3", 3],
                ["4", 4],
                ["5", 5],
                ["6", 6],
                ["7", 7],
                ["8", 8],
                ["9", 9],
                ["A", 10],
                ["B", 11],
                ["C", 12],
                ["D", 13],
                ["E", 14],
                ["F", 15],
                ["G", 16],
                ["H", 17],
                ["I", 18],
                ["J", 19],
                ["K", 20],
                ["L", 21],
                ["M", 22],
                ["N", 23],
                ["O", 24],
                ["P", 25],
                ["Q", 26],
                ["R", 27],
                ["S", 28],
                ["T", 29],
                ["U", 30],
                ["V", 31],
                ["W", 32],
                ["X", 33],
                ["Y", 34],
                ["Z", 35]
            ]);
            const weightFactorTable = [7, 3, 1];
            let sum = 0;
            for(let i = startPosition, j = 0; i <= endPosition; i++) {
                let value = transliterationKey.get(code[i]);
                if(value) {
                    sum += value*weightFactorTable[j%3];
                }
                j++;
            }
            return sum%10;
        };
        const checkDigit_9 = calculateMRPCheckDigit(code, 0, 8).toString();
        const checkDigit_19 = calculateMRPCheckDigit(code, 13, 18).toString();
        const checkDigit_27 = calculateMRPCheckDigit(code, 21, 26).toString();
        return checkDigit_9 === code[9] && checkDigit_19 === code[19] && checkDigit_27 === code[27];
    }

    /**
     * check if the two row or third row of id card mrz code is valid.
     * check digit only exits in two row or third row in id card mrz.
     * @ignore 
     */
    private _checkValidIDCard(code: string, codeUpperLine?: string): boolean {
        if(!code || (code.length != 30 && code.length != 36)) {
            return false;
        }
        const calculateMRICheckDigit = (code: string, startPosition: number, endPosition: number)=>{
            const transliterationKey = new Map([
                ["<", 0],
                ["0", 0],
                ["1", 1],
                ["2", 2],
                ["3", 3],
                ["4", 4],
                ["5", 5],
                ["6", 6],
                ["7", 7],
                ["8", 8],
                ["9", 9],
                ["A", 10],
                ["B", 11],
                ["C", 12],
                ["D", 13],
                ["E", 14],
                ["F", 15],
                ["G", 16],
                ["H", 17],
                ["I", 18],
                ["J", 19],
                ["K", 20],
                ["L", 21],
                ["M", 22],
                ["N", 23],
                ["O", 24],
                ["P", 25],
                ["Q", 26],
                ["R", 27],
                ["S", 28],
                ["T", 29],
                ["U", 30],
                ["V", 31],
                ["W", 32],
                ["X", 33],
                ["Y", 34],
                ["Z", 35]
            ]);
            const weightFactorTable = [7, 3, 1];
            let sum = 0;
            for(let i = startPosition, j = 0; i <= endPosition; i++) {
                let value = transliterationKey.get(code[i]);
                if(value) {
                    sum += value*weightFactorTable[j%3];
                }
                j++;
            }
            return sum%10;
        };
        if(code.length === 30) {
            if(codeUpperLine && code === codeUpperLine) {
                const checkDigit_14 = calculateMRICheckDigit(code, 5,13).toString();
                return checkDigit_14 === code[14];
            } else if(codeUpperLine && code !== codeUpperLine) {
                const combString = `${codeUpperLine.substring(5,30)}${code.substring(0,7)}${code.substring(8,15)}${code.substring(18,29)}`;
                const checkDigitMiddleLine = calculateMRICheckDigit(combString,0,combString.length-1).toString();
                return checkDigitMiddleLine === code[29];
            }
        } else if(code.length === 36) {
            const checkDigit_9 = calculateMRICheckDigit(code, 0,8).toString();
            const checkDigit_19 = calculateMRICheckDigit(code, 13,18).toString();
            const checkDigit_27 = calculateMRICheckDigit(code, 21,26).toString();

            const  lowerLine = `${code.substring(0,10)}${code.substring(13,20)}${code.substring(21,28)}`;
            const checkDigit_35 = calculateMRICheckDigit(lowerLine, 0, lowerLine.length-1).toString();

            return checkDigit_9 === code[9] && checkDigit_19 === code[19] && checkDigit_27 === code[27] && checkDigit_35 === code[35];
        }
    }

    /**
     * _promiseStartScan.status == "pending"; // camera is openning.
     * _promiseStartScan.status == "fulfilled"; // camera is opened.
     * _promiseStartScan == null; // camera is closed.
     * @ignore
     */
    private _promiseStartScan:MutablePromise<PlayCallbackInfo> = null;
    /**
     * Bind UI, open the camera, start recognizing.
     * ```js
     * await scanner.startScanning(); // Don not modify DOM. Usually used in framework like React, Vue, Angular.
     * ```
     * Bind UI, open the camera, start recognizing, and remove the UIElement `display` style if the original style is `display:none;`.
     * ```js
     * await scanner.startScanning(true); // Modify Dom and show UI. Useful when you don't use framework.
     * ```
     * @category Open and Close
     */
    async startScanning(bShowUI?: boolean): Promise<PlayCallbackInfo>{
        if(!this.dce && !this.imgSource) throw new Error(`'imageSource' is not set. call 'setImageSource()' before 'startScanning()'.`);
        if(this._promiseStartScan && this._promiseStartScan.isPending) return this._promiseStartScan;
        this._promiseStartScan = new MutablePromise<PlayCallbackInfo>();
        let info = null;
        if(this.dce) {
            if(!this.dce.isOpen()) {
                info = await this.dce.open(bShowUI);
                if(!this._promiseStartScan) return null;
            } else {
                bShowUI&&this.dce.appendAndShowUI();
                info = JSON.parse(JSON.stringify(this.dce.playCallbackInfo));
            }
            this._bindUI();
            if(this._dceControler) {
                this._dceControler.clearUserDisiredAction({user:this, actionName: "close"});
                this._dceControler.clearUserDisiredValue({property: "ifShowScanRegionLaser"});
                this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", true);
                if(this.dce.ifShowScanRegionLaser) {
                    this.dce.showScanRegionLaser();
                }
            }
        }
        this._bPauseScan = false;
        if(!(this.dce && this.dce.singleFrameMode)){
            this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
            this._loopReadVideoTimeoutId = setTimeout(()=>{
                if(this.dce) {
                    this.dce.startFetchingLoop();
                    if(this._dceControler) {
                        this._dceControler.clearUserDisiredAction({user:this, actionName: "stopFetchingLoop"})
                    }
                }
                this._loopReadVideo();
            }, 0);
        }
        this._promiseStartScan.resolve(info);
        return info;
    }

    /**
     * Stop decoding, release camera, unbind UI.
     * @category Open and Close
     */
    stopScanning(bHideUI?: boolean){
        if(this.dce) {
            this._drawResults(null);
            this._unbindUI();
            if(this._dceControler) {
                this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", false);
                if(!this.dce.ifShowScanRegionLaser) {
                    this.dce.hideScanRegionLaser();
                }
                this._dceControler.setDisiredAction(this, "close", [bHideUI]);
            }
        }
        this._bPauseScan = true;
        this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
        this.array_decodeFrameTimeCost.length = 0;
        this.array_getFrameTimeCost.length = 0;
        this._intervalGetVideoFrame = 0;
        this._promiseStartScan = null;
    }

    /**
     * Pause the recognizing process.
     * @category Pause and Resume
     */
    pauseScanning(options?:any) {
        if(!options || !options.keepResultsHighlighted) {
            this._drawResults(null);
        }
        this._bPauseScan = true;
        this._vinResultArray = [];
        if(this.dce) {
            if(this.dce.singleFrameMode) throw new Error(`'pauseScanning()' is unavailable when property 'singleFrameMode' of the 'CameraEnhancer' instance is true.`);
            if(this._dceControler) {
                this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", false);
                if(!this.dce.ifShowScanRegionLaser) {
                    this.dce.hideScanRegionLaser();
                }
                this._dceControler.setDisiredAction(this, "stopFetchingLoop");
            }
        }
        // this._clearRegionsults();
    }

    /**
     * Resume the recognizing process.
     * @category Pause and Resume
     */
    resumeScanning() {
        this._bPauseScan = false;
        if(this.dce) {
            if(this.dce.singleFrameMode) throw new Error(`'resumeScanning()' is unavailable when property 'singleFrameMode' of the 'CameraEnhancer' instance is true.`);
            this.dce.startFetchingLoop();
            if(this._dceControler) {
                this._dceControler.clearUserDisiredAction({user:this, actionName: "stopFetchingLoop"})
                this._dceControler.clearUserDisiredValue({property: "ifShowScanRegionLaser"});
                this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", true);
                if(this.dce.ifShowScanRegionLaser) {
                    this.dce.showScanRegionLaser();
                }
            }
        }
    }

    /**
     * Destructor the `LabelRecognizer` object.
     * @category Initialize and Destroy
     * @ignore
     */
    destroyContext(): Promise<void>{
        if(this.bDestroyed) return;
        if(LabelRecognizer._onLog)LabelRecognizer._onLog('destroy()');
        this.bDestroyed = true;
        if(this.dce || !this._promiseStartScan){
            this.stopScanning(true);
        }
        this.setImageSource(null);
        return new Promise((resolve, reject) =>{
            let taskID = LabelRecognizer._nextTaskID++;
            LabelRecognizer._taskCallbackMap.set(taskID, (body:any) => {
                if(body.success){
                    return resolve();
                }
                else{
                    let ex = new Error(body.message);
                    ex.stack = body.stack + '\n' + ex.stack;
                    return reject(ex);
                }
            });
            LabelRecognizer._dlrWorker.postMessage({
                type:"destroy",
                "id":taskID,
                "instanceID": this._instanceID,
            })
        })
    }
}