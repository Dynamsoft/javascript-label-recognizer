import { bNode, globalThis as gthis } from "detect-browser-node-ssr";
import { parentPort as nodeWorkerParentPort, MessagePort as nodeWorkerMessagePort } from 'node:worker_threads';
import MutablePromise from 'mutable-promise';
import { createDlsInstance, DlsInstance } from '@scannerproxy/dlsjs';

declare var Module: any;
declare var KModule: any;

let parentPort = bNode ? nodeWorkerParentPort : gthis;

let bWasmDebug: boolean;
let engineResourcePath: string;
let product = "dlr";
let version: string;
let wasmClassName = "LabelRecognizerWasm";

let bRuntimeAuth: boolean;
let trial: boolean;
let msgFromLtsServer: string;
let ltsInstance: DlsInstance;

let imageBufferMaxSize = 0;
let ptrImageBuffer = 0;
const setImageBufferIntoWasm = (u8ImageBuffer: Uint8Array, size: number) => {
  if (size > imageBufferMaxSize) {
    if (ptrImageBuffer) { Module._free(ptrImageBuffer); }
    ptrImageBuffer = Module._malloc(size);
    imageBufferMaxSize = size;
  }
  Module.HEAPU8.set(u8ImageBuffer.subarray(0, size), ptrImageBuffer);
};

let promiseWasmReady = new MutablePromise<void>();
let bHaveCalledLoadWasm = false;
let loadWasm = async () => {
  if (bHaveCalledLoadWasm) { throw "can't load wasm twice"; }
  bHaveCalledLoadWasm = true;
  log("wasm loading...");
  let timeStartLoadWasm = Date.now();

  await new Promise<void>(async (rs) => {
    // Module need to define in globalthis, so wasm can use it
    // KModule is used to walk around bug for safari 13.0.2 in mac 10.15
    gthis.KModule = gthis.Module = { // eslint-disable-line
      //dynamicLibraries: ["libDM_Statistic.wasm"],
      locateFile: function (path: string) {//(path, prefix)
        if (path == 'libDynamsoftLabelRecognizer.wasm') {
          return engineResourcePath + product + '-' + version + '.wasm';
        } else {
          return engineResourcePath + path;
        }
      },
      print: (message: string) => {
        log(message);
      },
      printErr: (message: string) => {
        log(message);
      },
      onRuntimeInitialized: rs
    };
    if (!bNode) {
      // in web worker
      importScripts(engineResourcePath + product + "-" + version + ".wasm.js");
    } else {
      // in nodejs
      let _Module = Module;
      Module = await import("./" + product + "-" + version + ".node.wasm.js"); // eslint-disable-line
      for (let field in _Module) {
        Module[field] = _Module[field];
      }
    }
  });


  log("wasm initialized, cost " + (Date.now() - timeStartLoadWasm) + " ms");

  if (!bNode) { Module = KModule; } // eslint-disable-line

  promiseWasmReady.resolve();
};

let updateLicense = async (initCfg: any) => {
  await promiseWasmReady;
  trial = initCfg.trial;
  msgFromLtsServer = initCfg.msg;
  Module[wasmClassName].init(JSON.stringify(initCfg));
};
let getMinExpireTime = () => {
  let f = Module[wasmClassName].getMinExpireTime;
  return f ? f() : null;
};
let getMaxExpireTime = () => {
  let f = Module[wasmClassName].getMaxExpireTime;
  return f ? f() : null;
};

let mapAppendedCaffeModel = {} as any; // modelName: true || promise<true> || throw ex

let mapInstances = new Map();
let nextInstanceID = 0;

const getBufferFromFileSystem = async (path: string) => {
  const fs = require("fs/promises");
  return await fs.readFile(path);
};

const checkAndAutoLoadCaffeModel = async (caffeModelName: string, folderUrl: string) => {
  // be very careful when modfiy this func. It uses a lot of coroutines. 
  if (!mapAppendedCaffeModel[caffeModelName]) {
    //console.log(caffeModelName,!!mapAppendedCaffeModel[caffeModelName]);//debug
    if (!folderUrl) {
      folderUrl = "";
    } else if (folderUrl === "@engineResourcePath") {
      folderUrl = engineResourcePath;
    }
    folderUrl += caffeModelName + '/';

    mapAppendedCaffeModel[caffeModelName] = (async () => {
      try {
        parentPort.postMessage({
          type: "event",
          body: {
            type: "resourcesLoadStarted",
            resourcesPath: folderUrl + caffeModelName + ".data"
          }
        });
        let data: any;
        let objHead: any;
        let lenHeadPart: any;
        const txtDecoder = new TextDecoder();

        if (!bNode) {
          const rep: any = await new Promise((rs, _) => {
            const xhr = new XMLHttpRequest() as any;
            xhr.responseType = 'arraybuffer';
            xhr.onload = () => {
              rs({ ok: true, arrayBuffer: () => xhr.response });
            };
            xhr.onerror = xhr.timeout = xhr.onabort = () => {
              rs({ ok: false, status: xhr.status });
            };
            let lastProcessTime = Date.now();
            // https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent
            xhr.onprogress = (pe: any) => {
              if (pe.lengthComputable) {
                const now = Date.now();
                if (lastProcessTime + 500 < now) {
                  parentPort.postMessage({
                    type: "event",
                    body: {
                      type: "resourcesLoadProgress",
                      loaded: pe.loaded,
                      total: pe.total,
                      resourcesPath: folderUrl + caffeModelName + ".data"
                    }
                  });
                  lastProcessTime = now;
                }
              }
            };
            xhr.open('GET', folderUrl + caffeModelName + ".data", true);
            xhr.send();
          });

          //const rep = await fetch(folderUrl+caffeModelName+".data");
          if (!rep.ok) { throw new Error(`Network error. Status: ${rep.status}.`); };
          data = await rep.arrayBuffer();
        } else {
          data = await getBufferFromFileSystem(folderUrl + caffeModelName + ".data");
        }

        // todo: nodejs
        {
          if (!txtDecoder.decode(new Uint8Array(data, 0, 8)).startsWith('DLR_MDL')) {
            throw new Error('Model data type incorrect.');
          }

          // byteorder little 
          let lenHeadContent = 0;
          // please notice the number should not bigger than `Number.MAX_SAFE_INTEGER`
          const bytesOfLen = new Uint8Array(data, 8, 8);
          for (let i = 7; i >= 0; --i) {
            lenHeadContent = lenHeadContent * 256 + bytesOfLen[i]; // do not use bit manipulation, because number may bigger than int 32
          }

          const strHead = txtDecoder.decode(new Uint8Array(data, 16, lenHeadContent));
          objHead = JSON.parse(strHead);

          lenHeadPart = 8 + 8 + lenHeadContent;
        }

        let getU8 = (fileName: string) => {
          const ss = objHead[fileName]; // start and size
          if (!ss) { throw new Error('File name not found.'); }
          return new Uint8Array(data, lenHeadPart + ss[0], ss[1]);
        };

        let obj = JSON.parse(txtDecoder.decode(getU8(caffeModelName + ".config.json")));
        // caffeModelName may not same as mainModel file name
        // e.g.
        // caffeModelName: "VIN", mainModel_fileName: "NumberUppercase"
        const mainModel_fileName = obj.mainModel;
        const assistModels = obj.assistModels;
        const modelFilter = obj.modelFilter;
        {
          const g1 = getU8(mainModel_fileName + ".prototxt"), g2 = getU8(mainModel_fileName + ".txt"), g3 = getU8(mainModel_fileName + ".caffemodel");
          Module[wasmClassName].appendCaffeModelBuffer(caffeModelName, g1, g2, g3);
        }
        if (assistModels) {
          for (let assistModelSuffix of assistModels) {
            const assistModelName = caffeModelName + assistModelSuffix;
            const prefix = mainModel_fileName + assistModelSuffix;
            const g1 = getU8(prefix + ".prototxt"), g2 = getU8(prefix + ".txt"), g3 = getU8(prefix + ".caffemodel");
            Module[wasmClassName].appendCaffeModelBuffer(assistModelName, g1, g2, g3);
          }
        }
        if (modelFilter) {
          Module[wasmClassName].appendModelFilterFileBuffer(caffeModelName, getU8(modelFilter + ".txt"));
        }
        mapAppendedCaffeModel[caffeModelName] = true;
        parentPort.postMessage({
          type: "event",
          body: {
            type: "resourcesLoaded",
            resourcesPath: folderUrl + caffeModelName + ".data"
          }
        });
        return true;
      } catch (ex) {
        delete mapAppendedCaffeModel[caffeModelName];
        //console.error(ex);//debug
        throw ex;
      }
    })();
  }
  await mapAppendedCaffeModel[caffeModelName]; // When Promise<ex>, throw ex. When Promise<true>, useless.
};

const applyNumberLetterRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "NumberLetter";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "NumberLetter";
  lrp.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [3, 999];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "NumberLetter";
  taa.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [3, 999];
};
const applyNumberRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "Number";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "Number";
  lrp.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  lrp.LetterHeightRange[0] = 5;
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "Number";
  taa.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [3, 999];
};
const applyLetterRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "Letter";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "Letter";
  lrp.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [3, 999];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "Letter";
  taa.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [3, 999];
};
const applyNumberUppercaseRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "NumberUppercase";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "NumberUppercase";
  lrp.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [3, 999];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "NumberUppercase";
  taa.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [3, 999];
};

const regMRP = `(P[A-Z<][A-Z][A-Z<]{41}){(44)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z<]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{14}[0-9<][0-9]){(44)}`;
const applyMRPRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "MRZ";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "MRZ";
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [44, 44];
  lrp.LineStringRegExPattern = regMRP.replace(/[\n\s]/g,"");
  lrp.MaxLineCharacterSpacing = 130;
  lrp.TextureDetectionModes[0].Sensitivity = 8;
  lrp.BinarizationModes[0].ThresholdCompensation = 15;
  settings.LineSpecificationArray = [{
    Name: "L0",
    LineNumber: "",
    BinarizationModes: [{
      BlockSizeX: 30,
      BlockSizeY: 30,
      Mode: "BM_LOCAL_BLOCK"
    }]
  }];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "MRZ";
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [44, 44];
  taa.LineStringRegExPattern = regMRP.replace(/[\n\s]/g,"");
  taa.MaxLineCharacterSpacing = 130;
  taa.TextureDetectionModes[0].Sensitivity = 8;
  taa.LineSpecificationNameArray = ["L0"];
  taa.BinarizationModes[0].ThresholdCompensation = 15;
};

const regMRV = `(V[A-Z<][A-Z][A-Z<]{33}){(36)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z<]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{8}){(36)}|
(V[A-Z<][A-Z][A-Z<]{41}){(44)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z<]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{14}[A-Z0-9<]{2}){(44)}`;
const applyMRVRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "MRZ";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "MRZ";
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [36, 44];
  lrp.LineStringRegExPattern = regMRV.replace(/[\n\s]/g,"");
  lrp.MaxLineCharacterSpacing = 130;
  lrp.TextureDetectionModes[0].Sensitivity = 8;
  lrp.BinarizationModes[0].ThresholdCompensation = 15;
  settings.LineSpecificationArray = [{
    Name: "L0",
    LineNumber: "",
    BinarizationModes: [{
      BlockSizeX: 30,
      BlockSizeY: 30,
      Mode: "BM_LOCAL_BLOCK",
    }]
  }];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "MRZ";
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [36, 44];
  taa.LineStringRegExPattern = regMRV.replace(/[\n\s]/g,"");
  taa.MaxLineCharacterSpacing = 130;
  taa.TextureDetectionModes[0].Sensitivity = 8;
  taa.LineSpecificationNameArray = ["L0"];
  taa.BinarizationModes[0].ThresholdCompensation = 15;
};

const regMRI = `([ACI][A-Z<][A-Z][A-Z<]{2}[A-Z0-9<]{9}[0-9<][A-Z0-9<]{15}){(30)}|
([0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z<]{3}[A-Z0-9<]{11}[0-9]){(30)}|
([A-Z][A-Z<]{29}){(30)}|
([ACI][A-Z<][A-Z][A-Z<]{33}){(36)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z<]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{8}){(36)}`;
const applyMRIRuntimeSettings = (settings:any) => {
  settings.CharacterModelArray[0].Name = "MRZ";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "MRZ";
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [30, 36];
  lrp.LineStringRegExPattern = regMRI.replace(/[\n\s]/g,"");
  lrp.MaxLineCharacterSpacing = 130;
  lrp.TextureDetectionModes[0].Sensitivity = 8;
  lrp.BinarizationModes[0].ThresholdCompensation = 15;
  settings.LineSpecificationArray = [{
    Name: "L0",
    LineNumber: "",
    BinarizationModes: [{
      BlockSizeX: 30,
      BlockSizeY: 30,
      Mode: "BM_LOCAL_BLOCK",
    }]
  }];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "MRZ";
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [30, 36];
  taa.LineStringRegExPattern = regMRI.replace(/[\n\s]/g,"");
  taa.MaxLineCharacterSpacing = 130;
  taa.TextureDetectionModes[0].Sensitivity = 8;
  taa.LineSpecificationNameArray = ["L0"];
  taa.BinarizationModes[0].ThresholdCompensation = 15;
}

const regMRZ = `([ACI][A-Z<][A-Z][A-Z<]{2}[A-Z0-9<]{9}[0-9<][A-Z0-9<]{15}){(30)}|
([0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z<]{3}[A-Z0-9<]{11}[0-9]){(30)}|
([A-Z][A-Z<]{29}){(30)}|([ACIV][A-Z<][A-Z][A-Z<]{33}){(36)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z<]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{8}){(36)}|
(I[A-Z<]FRA[A-Z<]{25}[A-Z0-9<]{6}){(36)}|([A-Z0-9<]{12}[0-9][A-Z<]{14}[0-9]{2}[(01-12)][(01-31)][0-9][MF<][0-9]){(36)}|
([PV][A-Z<][A-Z][A-Z<]{41}){(44)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{14}[0-9<][0-9]){(44)}|
([A-Z0-9<]{9}[0-9][A-Z][A-Z]{2}[0-9<]{6}[0-9][MF<][0-9]{2}[(01-12)][(01-31)][0-9][A-Z0-9<]{14}[A-Z0-9<]{2}){(44)}`;
const applyMRZRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "MRZ";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "MRZ";
  lrp.LetterHeightRange[0] = 5;
  lrp.LineStringLengthRange = [30, 44];
  lrp.LineStringRegExPattern = regMRZ.replace(/[\n\s]/g,"");
  lrp.MaxLineCharacterSpacing = 130;
  lrp.TextureDetectionModes[0].Sensitivity = 8;
  lrp.BinarizationModes[0].ThresholdCompensation = 15;
  settings.LineSpecificationArray = [{
    Name: "L0",
    LineNumber: "",
    BinarizationModes: [{
      BlockSizeX: 30,
      BlockSizeY: 30,
      Mode: "BM_LOCAL_BLOCK",
    }]
  }];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "MRZ";
  taa.LetterHeightRange[0] = 5;
  taa.LineStringLengthRange = [30, 44];
  taa.LineStringRegExPattern = regMRZ.replace(/[\n\s]/g,"");
  taa.MaxLineCharacterSpacing = 130;
  taa.TextureDetectionModes[0].Sensitivity = 8;
  taa.LineSpecificationNameArray = ["L0"];
  taa.BinarizationModes[0].ThresholdCompensation = 15;
};

const regVIN = "([0-9A-Z]{17,19}){(17,19)}";
const applyVINRuntimeSettings = (settings: any) => {
  settings.CharacterModelArray[0].Name = "VIN";
  const lrp = settings.LabelRecognizerParameterArray[0];
  lrp.CharacterModelName = "VIN";
  lrp.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  lrp.BinarizationModes[0].Mode = "BM_LOCAL_BLOCK";
  lrp.BinarizationModes[0].EnableFillBinaryVacancy = 0;
  lrp.LineStringRegExPattern = regVIN;
  lrp.LineStringLengthRange = [17, 19];
  lrp.LetterHeightRange = [5, 1000, 1];
  const taa = settings.TextAreaArray[0];
  taa.CharacterModelName = "VIN";
  taa.GrayscaleTransformationModes[0] = { Mode: "GTM_AUTO" };
  taa.BinarizationModes[0].Mode = "BM_LOCAL_BLOCK";
  taa.BinarizationModes[0].EnableFillBinaryVacancy = 0;
  taa.LineStringRegExPattern = regVIN;
  taa.LineStringLengthRange = [17, 19];
  taa.LetterHeightRange = [5, 1000, 1];
};

const applyVideoRuntimeSettings = (settings: any) => {
  const lrp = settings.LabelRecognizerParameterArray[0];
  if (settings.CharacterModelArray[0].Name === "VIN") {
    lrp.LineStringLengthRange = [17, 19];
    settings.TextAreaArray[0].LineStringLengthRange = [17, 19];
  }
  let minHeight = lrp.LetterHeightRange[0] * 10;
  const minHeightLimit = Math.max(500, lrp.LetterHeightRange[0]);
  if (minHeight >= minHeightLimit) {
    minHeight = minHeightLimit;
  }
  lrp.LetterHeightRange[0] = minHeight;
  settings.TextAreaArray[0].LetterHeightRange[0] = minHeight;
};

let onMainThreadMessage = async function (e: any) {
  const data = e.data ? e.data : e;
  const taskID = data.id;
  const instanceID = data.instanceID;
  const body = data.body;

  if (bRuntimeAuth && (data.type == "recognizeByBuffer")) {
    await ltsInstance.c();//checkAndReauth
  }

  switch (data.type) {
    case "loadWasm": {
      try {
        bWasmDebug = data.bd;
        engineResourcePath = data.engineResourcePath;
        //bUseFullFeature = data.bUseFullFeature;
        version = data.v;
        let domain = data.dm;
        let productKeys = data.l;
        bRuntimeAuth = data.brtk;
        let bPublicTryKey = data.bptk;

        loadWasm();
        let ltsErrorCode;
        let funcProcessRuntimeAuth = async () => {
          try {
            ltsInstance = createDlsInstance({ log: log, bd: bWasmDebug, dm: domain });// eslint-disable-line no-undef //,fol:console.warn
            // this method need to define in global, so wasm can use it, send consume save db
            gthis.scsd = ltsInstance.s;//secretAndSendToDb // todo: instead of a func in global, a function point into wasm may better
            data.pd = 'dlr';
            data.updl = updateLicense;
            data.mnet = getMinExpireTime;
            data.mxet = getMaxExpireTime;
            await ltsInstance.i(data);//initLicense
          } catch (ex) {
            if (bPublicTryKey) {
              bRuntimeAuth = false;
              await funcProcessProductKey();
              ltsErrorCode = ex.ltsErrorCode;
              msgFromLtsServer = ex.message || ex;
            } else {
              throw ex;
            }
          }
        };
        let funcProcessProductKey = async () => {
          let initCfg = {
            pk: productKeys,
            dm: domain,
          } as any;
          if (bWasmDebug) { initCfg.bd = true; }
          await updateLicense(initCfg);
        };
        bRuntimeAuth ? await funcProcessRuntimeAuth() : await funcProcessProductKey();
        parentPort.postMessage({
          type: "load",
          success: true,
          version: Module[wasmClassName].getVersion(),
          trial: trial,
          ltsErrorCode: ltsErrorCode,
          message: msgFromLtsServer,
        });
      } catch (ex) {
        let message = ex && ex.message;
        parentPort.postMessage({
          type: "load",
          success: false,
          ltsErrorCode: ex && ex.ltsErrorCode,
          message: message,
          trial: trial,
          stack: bWasmDebug && ex ? ex.stack : null
        });
      }
      break;
    }
    case "createInstance": {
      const instanceID = nextInstanceID++;
      try {
        let instance = new Module[wasmClassName](data.bScanner, instanceID);
        instance.currentCaffeModelName = "NumberLetter";
        mapInstances.set(instanceID, instance);
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          instanceID: instanceID
        }
      });
      break;
    }
    case "destroy": {
      try {
        if (!mapInstances.get(instanceID)) break;
        mapInstances.get(instanceID).delete();
        mapInstances.delete(instanceID);
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "recognizeByBuffer": {
      let timeWorkerGetMsg = Date.now(), timeBeforeSendBufferToWasm, timeBeforeDecode, timeFinishDecode;
      let decodeReturn;
      let bufferTransferBack = body.imageData.bytes;
      try {
        const instance = mapInstances.get(instanceID);

        await checkAndAutoLoadCaffeModel(instance.currentCaffeModelName, engineResourcePath);

        timeBeforeSendBufferToWasm = bWasmDebug ? Date.now() : 0;
        setImageBufferIntoWasm(body.imageData.bytes, body.imageData.stride * body.imageData.height);
        body.imageData.bytes = { ptr: ptrImageBuffer };
        timeBeforeDecode = bWasmDebug ? Date.now() : 0;
        decodeReturn = JSON.parse(instance.recognizeByBuffer(JSON.stringify(body.imageData), body.config && body.config.modelName || "", !!(body.config && body.config.bScanner)));
        timeFinishDecode = Date.now();
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          decodeReturn: decodeReturn,
          buffer: bufferTransferBack,
          duration: Date.now() - timeWorkerGetMsg
        }
      });
      //for debug
      //console.log("Object to be returned: ",decodeReturn);
      debugLog(["timeWorkerGetMsg: " + timeWorkerGetMsg,
      "timeBeforeSendBufferToWasm: " + timeBeforeSendBufferToWasm + " " + (timeBeforeSendBufferToWasm - timeWorkerGetMsg),
      "timeBeforeDecode: " + timeBeforeDecode + " " + (timeBeforeDecode - timeBeforeSendBufferToWasm),
      "timeFinishDecode: " + timeFinishDecode + " " + (timeFinishDecode - timeBeforeDecode)
      ].join('\n'));// for debug
      break;
    }
    case "updateReferenceRegionFromBarcodeResults": {
      let updateReturn;
      try {
        updateReturn = JSON.parse(mapInstances.get(instanceID).updateReferenceRegionFromBarcodeResults(JSON.stringify(body.dbrTextResults), ""));
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          updateReturn: updateReturn
        }
      });
      break;
    }
    case "clearMapDecodeRecord": {
      try {
        mapInstances.get(instanceID).clearMapDecodeRecord();
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "resetRuntimeSettings": {
      try {
        const instance = mapInstances.get(instanceID);
        instance.currentCaffeModelName = "NumberLetter";
        instance.resetRuntimeSettings();
      } catch (ex) {
        handleErr(e, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "appendSettingsFromString": {
      let updateReturn;
      try {
        updateReturn = JSON.parse(mapInstances.get(instanceID).appendSettingsFromString(body.settings));
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          updateReturn: updateReturn
        }
      });
      break;
    }
    case "clearAppendedSettings": {
      try {
        let reader = mapInstances.get(instanceID);
        reader.clearAppendedSettings();
      } catch (ex) {
        handleErr(e, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "updateRuntimeSettingsFromString": {
      let updateReturn;
      try {
        const instance = mapInstances.get(instanceID);
        let settings = body.settings;
        if ('string' === typeof settings) {
          settings = settings.trim();
          if (settings.startsWith('{')) {
            settings = JSON.parse(settings);
          } else {
            if (settings.length > 50) {
              throw new Error("Error: preset longer than 50 letters.");
            }
            const presetDefines = settings.toLowerCase().split('-');
            if (presetDefines.length > 2) {
              throw new Error(`Error: '${settings}' is not supported.`);
            }
            instance.resetRuntimeSettings();
            settings = JSON.parse(instance.outputSettingsToString());
            if (presetDefines.includes("numberletter")) {
              applyNumberLetterRuntimeSettings(settings);
            } else if (presetDefines.includes("number")) {
              applyNumberRuntimeSettings(settings);
            } else if (presetDefines.includes("letter")) {
              applyLetterRuntimeSettings(settings);
            } else if (presetDefines.includes("numberuppercase")) {
              applyNumberUppercaseRuntimeSettings(settings);
            } else if (presetDefines.includes("passportmrz")) {
              applyMRPRuntimeSettings(settings);
            } else if (presetDefines.includes("visamrz")) {
              applyMRVRuntimeSettings(settings);
            } else if(presetDefines.includes("idcardmrz")) {
              applyMRIRuntimeSettings(settings);
            } else if (presetDefines.includes("mrz")) {
              applyMRZRuntimeSettings(settings);
            } else if (presetDefines.includes("vin")) {
              applyVINRuntimeSettings(settings);
            } else if (presetDefines.includes("vin_na")) {
              applyVINRuntimeSettings(settings);
            } else if (presetDefines.includes("cppdefault")) {
              // do nothing
            } else {
              throw new Error(`Error: '${settings}' is not supported.`);
            }
            if (presetDefines.includes("video")) {
              applyVideoRuntimeSettings(settings);
            }
          }
        }

        const caffeModelName = settings.CharacterModelArray[0].Name;
        instance.currentCaffeModelName = caffeModelName;
        updateReturn = JSON.parse(instance.updateRuntimeSettingsFromString(JSON.stringify(settings)));

        await checkAndAutoLoadCaffeModel(caffeModelName, engineResourcePath);
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          updateReturn: updateReturn
        }
      });
      break;
    }
    case "outputSettingsToString": {
      let settings;
      try {
        settings = mapInstances.get(instanceID).outputSettingsToString();
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          results: settings
        }
      });
      break;
    }
    case "appendCaffeModelBuffer": {
      try {
        await checkAndAutoLoadCaffeModel(body.name, body.folderUrl);
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "eraseCaffeModelByName": {
      try {
        Module[wasmClassName].eraseCaffeModelByName(body.name);
        delete mapAppendedCaffeModel[body.name];
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "eraseAllCaffeModels": {
      try {
        Module[wasmClassName].eraseAllCaffeModels();
        mapAppendedCaffeModel = {};
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "updateScanSettings": {
      try {
        let scanner = mapInstances.get(instanceID);
        let settings = body.settings;
        scanner.duplicateForgetTime = settings.duplicateForgetTime;
        scanner.rememberFrameCount = settings.rememberFrameCount;
        scanner.trustFrameCount = settings.trustFrameCount;
        // if(settings.frameFilter){
        //     scanner.setFrameFilter(JSON.stringify(settings.frameFilter));
        // }else{
        //     scanner.setFrameFilter("");
        // }

      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true
        }
      });
      break;
    }
    case "getScanSettings": {
      let settings = {} as any;
      try {
        let scanner = mapInstances.get(instanceID);
        settings.duplicateForgetTime = scanner.duplicateForgetTime;
        settings.rememberFrameCount = scanner.rememberFrameCount;
        settings.trustFrameCount = scanner.trustFrameCount;
        // let frameFilter = scanner.getFrameFilter();
        // if(frameFilter){
        //     settings.frameFilter = JSON.parse(frameFilter);
        // }
      } catch (ex) {
        handleErr(ex, taskID);
        break;
      }
      parentPort.postMessage({
        type: "task",
        id: taskID,
        body: {
          success: true,
          results: settings
        }
      });
      break;
    }
    default:
      console.warn("Unmatched task: ", e); // eslint-disable-line
      break;
  }
};
/**
 * https://nodejs.org/api/worker_threads.html#worker_threads_broadcastchannel_onmessage
 * node >= 15 can use `else`, but don't use both way. If you use both, it will do twice onmessage
 */
if (bNode) {
  (parentPort as nodeWorkerMessagePort).on('message', onMainThreadMessage);
} else {
  (parentPort as any).onmessage = onMainThreadMessage;
}

let log = (message: string) => {
  parentPort.postMessage({
    type: "log",
    message: message
  });
};
let debugLog = (message: string) => {
  bWasmDebug && log(message);
};

let handleErr = (ex: Error, taskID: number) => {
  parentPort.postMessage({
    type: "task",
    id: taskID,
    body: {
      success: false,
      message: ex.message,
      stack: ex.stack
    }
  });
  setTimeout(() => {
    throw ex;
  }, 0);
};
export {}
